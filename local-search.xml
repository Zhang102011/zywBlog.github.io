<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello JVM</title>
    <link href="/2023/07/19/JVM/"/>
    <url>/2023/07/19/JVM/</url>
    
    <content type="html"><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="/image/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>程序计数器（Program Counter Register）可以看作是当前线程所执行的字节码的行号指示器</p><p><img src="/image/JVM/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.png"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>线程私有</li><li>不会存在内存溢出</li></ul><p>Java虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存</p><h2 id="JAVA虚拟机栈"><a href="#JAVA虚拟机栈" class="headerlink" title="JAVA虚拟机栈"></a>JAVA虚拟机栈</h2><p>与程序计数器一样，JAVA虚拟机栈也是线程私有的，它的生命周期与线程相同</p><p><img src="/image/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png"></p><p>每个方法被执行的时候，JAVA虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</p><p>垃圾回收是不涉及栈内存的</p><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>不共享变量不存在线程安全问题，共享变量存在线程安全问题，例如被static修饰的变量，在被多线程操作时就会出现线程安全问题</p><h3 id="内存溢出问题"><a href="#内存溢出问题" class="headerlink" title="内存溢出问题"></a>内存溢出问题</h3><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</p><p><img src="/image/JVM/StackOverflowError.png"></p><p>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常</p><p>虚拟机栈为虚拟机执行java方法（也就是字节码）服务，而本地方发栈则是为虚拟机使用到的本地方法（Native）服务</p><h2 id="Java堆（Java-Heap）"><a href="#Java堆（Java-Heap）" class="headerlink" title="Java堆（Java Heap）"></a>Java堆（Java Heap）</h2><p>Java堆(Java Heap)是虚拟机所管理内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例、</p><h3 id="内存溢出问题-1"><a href="#内存溢出问题-1" class="headerlink" title="内存溢出问题"></a>内存溢出问题</h3><p>Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”。Java堆他存在垃圾回收，但是也存在着内存溢出的问题。当新产生的对象要依赖于旧对象时，旧对象就不能被垃圾回收，如果数据量比较大，则可能存在内存溢出的问题</p><p><img src="/image/JVM/%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.png"></p><p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（TLAB），以提升对象分配时的效率。将Java堆细分的目的只是为了更好的回收内存，或者更快的分配内存</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态常量、即时编译器编译后的代码缓存等数据。</p><p><img src="/image/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E7%BB%93%E6%9E%84.png"></p><h2 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h2><p>运行时常量池是方法区的一部分</p><p>常量池表用于存放编译期生成的各种字面量与符号引用，这部分内容将在<strong>类加载后</strong>存放带方法区的运行时常量池中</p><p>运行时常量池相对于Class文件常量池的另外一个重要的特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，通过String类的intern（）方法可以将运行期间产生的常量放入池中</p><p>intern()这个方法在JDK1.6与JDK1.8有着区别：在JDK1.6中此方法将常量放入池中时会复制一份该常量，将复制的副本放入常量池中。然而在JDK1.8后放入的是该常量本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">String s1=<span class="hljs-string">&quot;a&quot;</span>;<br>String s2=<span class="hljs-string">&quot;b&quot;</span>;<br>String s3=<span class="hljs-string">&quot;ab&quot;</span>;<br>String s4=s1+s2;<span class="hljs-comment">//new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()==new String(&quot;ab&quot;)</span><br>String s5=<span class="hljs-string">&quot;a&quot;</span>+<span class="hljs-string">&quot;b&quot;</span>;<span class="hljs-comment">//s3==s5,直接在字符串池中找到&quot;ab&quot;,并不是分别找到&quot;a&quot;，&quot;b&quot;将其拼接</span><br></code></pre></td></tr></table></figure><h2 id="字符串池（StringTable）"><a href="#字符串池（StringTable）" class="headerlink" title="字符串池（StringTable）"></a>字符串池（StringTable）</h2><h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><ul><li><h3 id="调整虚拟机参数-XX-StringTableSize"><a href="#调整虚拟机参数-XX-StringTableSize" class="headerlink" title="调整虚拟机参数-XX:StringTableSize"></a>调整<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>参数-XX:StringTableSize</h3></li><li><h3 id="考虑将字符串入池"><a href="#考虑将字符串入池" class="headerlink" title="考虑将字符串入池"></a>考虑将字符串入池</h3></li></ul><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><h3 id="字符串池中的对象也会被垃圾回收器回收"><a href="#字符串池中的对象也会被垃圾回收器回收" class="headerlink" title="字符串池中的对象也会被垃圾回收器回收"></a>字符串池中的对象也会被垃圾回收器回收</h3><h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><p>在JDK1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道与缓冲区的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后用过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制</p><p><img src="/image/JVM/%E6%99%AE%E9%80%9A%E7%9A%84%E8%AF%BB%E5%8F%96%E6%96%B9%E5%BC%8F%E2%80%99.png"></p><p><img src="/image/JVM/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E2%80%98.png"></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="如何判断对象可以被回收"><a href="#如何判断对象可以被回收" class="headerlink" title="如何判断对象可以被回收"></a>如何判断对象可以被回收</h3><ol><li><p>引用计数算法：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的</p><p>缺点：难以解决对象之间相互循环引用的问题</p></li><li><p>可达性分析算法：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的</p><p><img src="/image/JVM/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png"></p><p>![](&#x2F;image&#x2F;JVM&#x2F;jvm\GC Roots.png)</p></li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><img src="/image/JVM/%E5%BC%95%E7%94%A8.png"></p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><ul><li>弱分代假说：绝大多数对象都是朝生夕灭的</li><li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡</li></ul><p><img src="/image/JVM/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png"></p><h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><ul><li><p>标记清除：Mark Sweep</p><p>速度较快，会造成内存碎片</p><p><img src="/image/JVM/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png"></p></li><li><p>标记整理算法：Mark Sweep</p><p>速度慢，不会产生内存碎片</p><p><img src="/image/JVM/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png"></p></li><li><p>复制算法：Copy</p><p>不会有内存碎片，需要占用双倍内存空间</p><p><img src="/image/JVM/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"></p></li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>串行：适用于单线程，堆内存较小 </p><p><img src="/image/JVM/jvm/%E4%B8%B2%E8%A1%8C.png"></p></li><li><p>吞吐量优先：适用于多线程，堆内存较大</p><p><img src="/image/JVM/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88.png">     </p></li><li><p>响应时间优先：适用于多线程，堆内存较大 </p><p><img src="/image/JVM/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88.png"></p></li></ul><h3 id="G1（Garbage-First）垃圾收集器"><a href="#G1（Garbage-First）垃圾收集器" class="headerlink" title="G1（Garbage First）垃圾收集器"></a>G1（Garbage First）垃圾收集器</h3><p>G1垃圾收集器它是里程石碑的垃圾收集器，它<strong>开创了面向局部收集的设计思路和基于Region内存布局形式</strong>。在JDK8Update40，G1收集器提供了并发的类卸载的支持，被Oracle公司认定为全功能的垃圾收集器</p><p>在规划JDK10的时候，HotSpot虚拟机提出了“统一垃圾收集器接口”，将内存回收的“行为”与“实现”进行分离，CMS以及其他收集器都重构成基于这套接口的一种实现（面向接口编程），这算是为CMS退出历史舞台铺下最后的道路</p><h4 id="G1收集器与CMS收集器的区别"><a href="#G1收集器与CMS收集器的区别" class="headerlink" title="G1收集器与CMS收集器的区别"></a>G1收集器与CMS收集器的区别</h4><p>CMS收集器：垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）</p><p>G1收集器：跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set）进行回收，衡量标准不再是它属于那个分代，而是那块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式</p><p>能够实现这一目标的关键是G1开创的基于Region的堆内存布局,G1不在坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</p><h4 id="Humongous区域"><a href="#Humongous区域" class="headerlink" title="Humongous区域"></a>Humongous区域</h4><p>专门存储大对象，G1认为只要大小超过一个Region容量一半的对象即可判定为大对象。对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</p><h4 id="G1收集器高效率"><a href="#G1收集器高效率" class="headerlink" title="G1收集器高效率"></a>G1收集器高效率</h4><p><img src="/image/JVM/G1%E6%94%B6%E9%9B%86%E5%99%A8%E9%AB%98%E6%95%88%E7%8E%87.png"></p><h4 id="G1在开发过程中的问题和解决方案"><a href="#G1在开发过程中的问题和解决方案" class="headerlink" title="G1在开发过程中的问题和解决方案"></a>G1在开发过程中的问题和解决方案</h4><ul><li>Region中存在跨Region引用对象如何解决</li></ul><p>  使用记忆集避免全堆作为GC Roots扫描，G1记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号，它是一种“双向”的卡表结构（卡表是：我指向谁，这种结构还记录了谁指向我）</p><ul><li><p>在并发标记阶段如何保证收集线程和用户线程互不干扰地进行</p><p><img src="/image/JVM/G1%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98.png"></p></li><li><p>如何建立起可靠的停顿预测模型</p><p>以衰减均值为理论基础来实现的</p></li></ul><h4 id="G1收集器的运作过程"><a href="#G1收集器的运作过程" class="headerlink" title="G1收集器的运作过程"></a>G1收集器的运作过程</h4><p>在不计算用户线程运行过程</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选标记</li></ul><p><img src="/image/JVM/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>可以由用户指定期望的停顿时间是G1收集器很强大的一个功能，设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。但是如果我们把停顿时间调的非常低，很有可能出现的结果就是由于停顿时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集器收集的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积</p><h4 id="为什么说G1是垃圾收集器技术发展的一个里程碑"><a href="#为什么说G1是垃圾收集器技术发展的一个里程碑" class="headerlink" title="为什么说G1是垃圾收集器技术发展的一个里程碑"></a>为什么说G1是垃圾收集器技术发展的一个里程碑</h4><p>从G1开始最先进的垃圾收集器设计导向都不约而同地变为追求能够应付应用的内存分配速率，而不追求一次把 整个Java堆全部清理干净。这样，应用在分配，同时收集器在收集，只要收集的速度能跟上对象分配的速度，那一切就可以运作得很完美</p><h4 id="G1收集器和CMS收集器的优缺点"><a href="#G1收集器和CMS收集器的优缺点" class="headerlink" title="G1收集器和CMS收集器的优缺点"></a>G1收集器和CMS收集器的优缺点</h4><p><img src="/image/JVM/G1%E5%92%8CCMS%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png"></p><h2 id="JavaIO-NIO"><a href="#JavaIO-NIO" class="headerlink" title="JavaIO&#x2F;NIO"></a>JavaIO&#x2F;NIO</h2><p><strong>阻塞IO</strong></p><p>当用户线程发起IO请求后，内核会去检查数据有没有准备好，如果没有准备好则用户线程交出CUP进入阻塞状态，直到数据准备好以后，内核将数据拷贝到用户线程，用户线程解除阻塞</p><p><strong>非阻塞IO</strong></p><p>非阻塞IO和阻塞IO相比，在数据未准备好时，用户线程不会交出CPU而是一直轮询的去询问内核数据有没有准备好，这种IO方式CPU的利用率会很高</p><p><strong>多路复用IO</strong></p><p><strong>异步IO</strong></p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>定义：Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称为虚拟机的类加载机制</p><h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p><img src="/image/JVM/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这个顺序按部就班的开始，而解析阶段则不一定：它在某些情况下可以在初始化后开始，这是为了支持Java语言的运行时绑定特性。请注意这里说的是各阶段按部就班的开始，而不是按部就班的进行，言下之意就是不是等一个阶段结束在进行下一个阶段，而是有可能两个阶段交叉相互执行</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载阶段，Java虚拟机需要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ol><p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，任然属于连接阶段的一部分，这两个阶段的开始时间任然保持着固定的先后顺序</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全</p><p>验证阶段大致上会完成下面四个阶段的验证动作：</p><ol><li><p>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</p><p>目的：保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求</p></li><li><p>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求</p><p>目的：对类的元数据信息进行语义校验</p></li><li><p>字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为</p></li><li><p>符号引用验证：此验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中各种符号引用）的各类信息进行匹配性校验，也就是该类是否缺少活着被禁止访问它依赖的某些外部类、方法、字段等资源</p><p>目的：确保解析阶段可以正常进行</p></li></ol><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段（在方法区中来分配内存，值得注意的是在JDK7之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK8及之后，类变量则会随着class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了）</p><p>在准备阶段进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配到Java堆中</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化阶段是类加载过程中的最后一个步骤。进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以说初始化阶段就是执行类构造器clinit()方法的过程</p><p>clinit()方法：</p><p>此方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(statin{}块)中的语句合并产生的，clinit()方法与类的构造函数（即在虚拟机视角中的实例构造器init()方法）不同，它不需要显示地调用父类构造器，Java虚拟机会保证在子类的clinit（）方法执行前，父类的clinit()方法已经执行完毕。所以在Java虚拟机中第一个被执行的linit()方法的类型肯定是java.lang.Object</p><p>由于父类的clinit()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</p><p>clinit()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成clinit()方法</p><p>Java虚拟机必须保证一个类的clinit()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的clinit()方法，其他线程都需要阻塞等待。直到活动线程执行完毕clinit()方法</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）</p><p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的加载器不同，那么这两个就必定不相等</p><p>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用了instanceof关键字做对象所属关系判定等各种情况</p><h2 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h2><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>Java内存模型的主要目的：定义程序中各种变量（能够被共享的变量）的访问规则，关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节</p><p>Java内存模型规定所有的变量都存储在主内存（在物理上它仅是虚拟机内存的一部分）中。每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的操作都必须在工作内存中进行，而不能直接读写主内存中的数据</p><p><img src="/image/JVM/%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png"></p><p>我们可以近似于把主内存和工作内存看成Java堆和虚拟机栈，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应虚拟机栈的部分区域，但是他们基本上是没有任何关系的</p><h4 id="内存的交互操作"><a href="#内存的交互操作" class="headerlink" title="内存的交互操作"></a>内存的交互操作</h4><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝带工作内存，如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下八种操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的</p><ul><li>lock（锁定）</li><li>unlock（解锁）</li><li>read（读取）</li><li>load（载入）</li><li>use（使用）</li><li>assign（赋值）</li><li>store（存储）</li><li>write（写入）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello Spring</title>
    <link href="/2023/07/19/Spring6/"/>
    <url>/2023/07/19/Spring6/</url>
    
    <content type="html"><![CDATA[<p>基于动力节点<a href="https://www.bilibili.com/video/BV1Ft4y1g7Fb/?spm_id_from=333.999.0.0&vd_source=090e0183092aedfd3bb1894177a01779">杜聚宾</a>老师的课程对Spring框架知识的总结</p><h2 id="Spring6"><a href="#Spring6" class="headerlink" title="Spring6"></a>Spring6</h2><h3 id="OCP开闭原则"><a href="#OCP开闭原则" class="headerlink" title="OCP开闭原则"></a>OCP开闭原则</h3><p>对拓展开放，对修改关闭</p><h3 id="DIP依赖倒置原则"><a href="#DIP依赖倒置原则" class="headerlink" title="DIP依赖倒置原则"></a>DIP依赖倒置原则</h3><p>提倡面向抽象编程，面向接口编程，不要面向具体编程，让上层不再依赖下层</p><h3 id="IoC控制反转"><a href="#IoC控制反转" class="headerlink" title="IoC控制反转"></a>IoC控制反转</h3><p>控制反转（Inversion of Control)，是一种面向对象编程的设计思想，可以用来降低代码之间的耦合度，符合依赖倒置原则</p><p>核心思想：<strong>将对象创建的权利交出去，将对象和对象之间关系维护的管理权交出去，让第三方容器来负责创建和维护</strong></p><p>方式：依赖注入（DI）</p><h3 id="Spring8大模块"><a href="#Spring8大模块" class="headerlink" title="Spring8大模块"></a>Spring8大模块</h3><p>Spring5中加入了Spring WebFlux构成八大模块</p><ul><li>Spring Core模块：这是Spring框架最基础的部分，她提供了依赖注入特征来实现容器对Bean的管理。核心容器的主要组件是BeanFactory，BeanFactory是工厂模式的一个实现，是任何Spring的核心。它使用IoC将应用配置和依赖从实际的应用代码中分离出来</li><li>Spring Context模块：Spring上下文模块就是Spring成为框架的原因。这个模块拓展了BeanFactory。增加了对国际化消息、事件传播、验证的支持。</li><li>Spring AOP模块：面向切面编程</li><li>Spring DAO模块：提供了单独的支持JDBC操作的API</li><li>Spring ORM模块：Spring提供了ORM模块，也可以集成其他ORM，例如：MyBatis、Hibernate</li><li>Spring Web MVC模块：Spring为构建Web应用提供了一个功能全面的MVC框架。</li><li>Spring WebFlux模块</li><li>Spring Web模块</li></ul><h3 id="Spring特点"><a href="#Spring特点" class="headerlink" title="Spring特点"></a>Spring特点</h3><p>轻量、控制反转、面向切面、容器、框架</p><h3 id="set注入的实现原理"><a href="#set注入的实现原理" class="headerlink" title="set注入的实现原理"></a>set注入的实现原理</h3><p>通过反射机制调用该对象的set方法来给属性赋值，让两个对象之间产生关系</p><h3 id="简单类型包括"><a href="#简单类型包括" class="headerlink" title="简单类型包括"></a>简单类型包括</h3><ul><li>基本数据类型及其对应的包装类</li><li>String或其他的CharSequence子类</li><li>Number子类</li><li>Date子类</li><li>Enum子类</li><li>URL</li><li>URI</li><li>Temporal子类</li><li>Locale</li><li>Class</li></ul><p>如果我们把Date当做简单类型的话，日期字符串格式不能随便写。格式必须符合Date的toString（）方法的格式</p><h3 id="Bean对象的创建"><a href="#Bean对象的创建" class="headerlink" title="Bean对象的创建"></a>Bean对象的创建</h3><p>默认情况下Bean是单例的，此时Bean对象的创建是在初始化Spring上下文的时候完成的</p><p>当Bean是多例的时，Bean对象的创建是在调用getBean（）方法时创建，并且调用一次创建一次</p><h3 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h3><ul><li>singleton：默认的，单例</li><li>prototype：原型。每调用一次getBean（）方法则获取一个新的Bean对象。</li><li>request：一个请求对应一个Bean</li><li>session：一个对话一个Bean</li><li>global session：protlet应用中专用</li><li>application：一个应用一个Bean</li><li>websocket：一个websocket一个Bean</li><li>自定义scope</li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="工厂模式的三种形态："><a href="#工厂模式的三种形态：" class="headerlink" title="工厂模式的三种形态："></a>工厂模式的三种形态：</h4><ul><li>简单工厂模式：很多物品对应一个工厂，不属于23种设计模式</li><li>工厂方法模式：一个物品对应一个工厂</li><li>抽象工厂模式</li></ul><h3 id="Bean的实例化"><a href="#Bean的实例化" class="headerlink" title="Bean的实例化"></a>Bean的实例化</h3><p>Bean实例化的方式：</p><ul><li>通过构造方法实例化：调用对象的无参构造进行实例化</li><li>通过简单工厂实例化</li><li>通过factory-bean实例化</li><li>通过FactoryBean接口实例化</li></ul><p>factory-bean实例化和FactoryBean不一样。</p><p>1.写法不一样，前者是通过两个<bean/>实现,后者是通过实现FactoryBean接口实现。</p><p>2.实现时机不一样，前者是在创建spring容器时通过dom4j读取<bean/>标签中的内容创建。后者是在执行getBean()获取他时创建。</p><h3 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h3><p>BeanFactory：Spring IoC容器的顶级对象，BeanFactory被翻译为“Bean工厂”，在Spring的IoC中，“Bean工厂”负责创建Bean对象。BeanFactory是工厂</p><p>FactoryBean：它是一个Bean，是一个能够辅助Spring实例化其他Bean对象的一个Bean</p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p>以Bean生命周期之10步为例：</p><ul><li><p><strong>实例化Bean</strong>：调用无参数构造方法</p></li><li><p><strong>Bean属性赋值</strong>：调用set方法</p></li><li><p>检查Bean是否实现了Aware的相关接口，并设置相关依赖（BeanNameAware、BeanClassLoaderAware、BeanFactoryAware）如果要在实例化Bean时要执行某些代码就可以通过实现Aware接口来完成</p></li><li><p><strong>Bean后处理器before执行</strong></p></li><li><p>检查Bean是否实现了InitializingBean接口，并调用接口方法</p></li><li><p><strong>初始化Bean</strong>：调用init方法，这个init方法需要我们自己写</p></li><li><p><strong>Bean后处理器after执行</strong></p></li><li><p><strong>使用Bean</strong></p></li><li><p>检查Bean是否实现了DisposableBean接口，并调用接口方法</p></li><li><p><strong>销毁Bean</strong>：调用自己写的destory方法</p><p>如果你想在初始化前和初始化后添加代码，可以加入“Bean后处理器”。</p><p>编写一个类实现BeanPostProcessor类，并且重写before和after方法</p></li></ul><h3 id="自己new的对象如何让Spring管理"><a href="#自己new的对象如何让Spring管理" class="headerlink" title="自己new的对象如何让Spring管理"></a>自己new的对象如何让Spring管理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//自己new的对象</span><br>User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><span class="hljs-comment">//创建 默认可列表BeanFactory对象</span><br>DefaultListableBeanFactory factory=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span>();<br><span class="hljs-comment">//注册Bean</span><br>factory.registerSingleton(<span class="hljs-string">&quot;userBean&quot;</span>,user);<br><span class="hljs-comment">//从Spring中获取bean</span><br>User userBean=factory.getBean(<span class="hljs-string">&quot;userBean&quot;</span>,User.class);<br></code></pre></td></tr></table></figure><h3 id="Bean的循环依赖问题"><a href="#Bean的循环依赖问题" class="headerlink" title="Bean的循环依赖问题"></a>Bean的循环依赖问题</h3><h4 id="singleton-set注入下"><a href="#singleton-set注入下" class="headerlink" title="singleton+set注入下"></a>singleton+set注入下</h4><p>在此情况下循环依赖是没有问题的</p><h4 id="singleton-构造注入下"><a href="#singleton-构造注入下" class="headerlink" title="singleton+构造注入下"></a>singleton+构造注入下</h4><p>在此情况下是不能解决循环依赖问题，主要原因就是通过构造方法注入会导致实例化对象的过程和对象属性赋值的过程没有分离开，必须在一起完成导致的</p><h4 id="Spring解决循环依赖问题的机理"><a href="#Spring解决循环依赖问题的机理" class="headerlink" title="Spring解决循环依赖问题的机理"></a>Spring解决循环依赖问题的机理</h4><p>通过singleton+set注入这种方式，将实例化对象和给对象属性赋值分开完成</p><p>实例化Bean的时候：调用无参数构造方法来完成。<strong>此时可以先不给属性赋值，可以提前将该Bean对象“曝光”给外界</strong></p><p>给Bean属性赋值的时候：调用setter方法来完成</p><p>这两个步骤是完全分离开来完成</p><h3 id="Bean的缓存问题"><a href="#Bean的缓存问题" class="headerlink" title="Bean的缓存问题"></a>Bean的缓存问题</h3><p>Bean的三级缓存：</p><ul><li>一级缓存（单例对象的缓存）：key存储bean名称，value存储Bean对象</li><li>二级缓存（早期单例对象的缓存）：key存储bean名称，value存储早期的Bean</li><li>三级缓存（单例工厂缓存）：key存储bean名称，value存储该Bean的ObjectFactory对象</li></ul><p>在DefaultSingletonBeanRegistry类中有一个addSingletonFactory（）方法，这个方法的作用是：将创建Bean对象的ObjectFactory对象提前曝光</p><p><img src="/image/Spring6/image1.png"></p><p>从源码分析可知：</p><p><img src="/image/Spring6/image.png"></p><h3 id="声明Bean的注解"><a href="#声明Bean的注解" class="headerlink" title="声明Bean的注解"></a>声明Bean的注解</h3><ul><li>@Component</li><li>@Controller</li><li>@Service</li><li>@Repository</li></ul><p><img src="/image/Spring6/image2.png"></p><p>value是可以省略的，省略后默认名字是Bean类名首字母小写</p><h3 id="负责注入的注解"><a href="#负责注入的注解" class="headerlink" title="负责注入的注解"></a>负责注入的注解</h3><ul><li><p>@Value：简单类型进行注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.powernode.spring6.bean4;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@Value(value = &quot;zhangsan&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;20&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>@Autowired：默认通过类型自动装配</p></li><li><p>@Qualifier：中指定Bean名称</p><p>这两个注解要结合起来使用，@Autowired根据类型自动装配，@Qualifier根据名字进行自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.powernode.spring6.service;<br><br><span class="hljs-keyword">import</span> com.powernode.spring6.dao.UserDao;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;userDaoForOracle&quot;)</span> <span class="hljs-comment">// 这个是bean的名字。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>        userDao.insert();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Autowired注解可以出现在：属性上、构造方法上、构造方法的参数上、setter方法上</p><p>当带参数的构造方法只有一个，@Autowired可以省略</p><p>@Autowired注解默认根据类型注入。如果要根据名称注入的话，需要配合@Qualifier注解一起使用</p></li><li><p>@Resource</p><p>该注解是JDK扩展包中的，就是说是JDK的一部分，@Autowired是Spring框架自己的</p><p>@Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配</p><p>@Resource注解可以用到属性上、setter方法上</p></li></ul><h3 id="Spring的全注解式开发"><a href="#Spring的全注解式开发" class="headerlink" title="Spring的全注解式开发"></a>Spring的全注解式开发</h3><p>通过以下配置来代替xml文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&#123;&quot;com.powernode.spring6.da0&quot;,&quot;com.powernode.spring6.service&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Spring6Configuration</span>()&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>JDK动态代理：只能代理接口，<strong>通过反射机制来动态代理</strong></p><p>CGLIB动态代理：是一个强大的，高性能的，高质量的Code生成类库，它可以在运行期间扩展Java类与实现Java接口。它既可以代理接口也可以代理类，<strong>底层是通过继承的方式实现的</strong>。性能比JDK动态代理要好（底层是一个小而快的字节码处理框架ASM）</p><p>javassist动态代理：通过使用javassist对字节码操作作为JBoss实现动态“AOP”框架</p><h3 id="面向切面编程AOP"><a href="#面向切面编程AOP" class="headerlink" title="面向切面编程AOP"></a>面向切面编程AOP</h3><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>一般一个系统当中都会有一些系统服务，例如：日志、事务管理、安全等。这些系统服务被称为：<strong>交叉业务</strong></p><p>AOP：将于核心业务无关的代码独立的抽取出来，形成一个独立的组件，然后以横向交叉的方法应用到业务流程当中的过程被称为AOP</p><p><img src="/image/Spring6/image3.png"></p><h4 id="AOP的七大术语"><a href="#AOP的七大术语" class="headerlink" title="AOP的七大术语"></a>AOP的七大术语</h4><ul><li><p>连接点Joinpoint</p></li><li><p>切点Pointcut</p></li><li><p>通知Advice</p></li><li><p>切面Aspect</p><p>切面&#x3D;切点+通知</p></li><li><p>织入</p></li><li><p>代理对象</p></li><li><p>目标对象</p></li></ul><p><img src="/image/Spring6/image4.png"></p><h4 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">execution([访问控制权限修饰符] 返回值类型 [全限定类名] 方法名(形式参数列表) [异常])<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">访问控制权限修饰符：</span><br><span class="hljs-comment">   可选项。</span><br><span class="hljs-comment">   没写，就是4个权限都包括。</span><br><span class="hljs-comment">   写public就表示只包括公开的方法。</span><br><span class="hljs-comment">返回值类型：</span><br><span class="hljs-comment">   必填项。</span><br><span class="hljs-comment">   * 表示返回值类型任意。</span><br><span class="hljs-comment">全限定类名：</span><br><span class="hljs-comment">   可选项。</span><br><span class="hljs-comment">   两个点“..”代表当前包以及子包下的所有类。</span><br><span class="hljs-comment">   省略时表示所有的类。</span><br><span class="hljs-comment">方法名：</span><br><span class="hljs-comment">   必填项。</span><br><span class="hljs-comment">   *表示所有方法。</span><br><span class="hljs-comment">   set*表示所有的set方法。</span><br><span class="hljs-comment">形式参数列表：</span><br><span class="hljs-comment">   必填项</span><br><span class="hljs-comment">   () 表示没有参数的方法</span><br><span class="hljs-comment">   (..) 参数类型和个数随意的方法</span><br><span class="hljs-comment">   (*) 只有一个参数的方法</span><br><span class="hljs-comment">   (*, String) 第一个参数类型随意，第二个参数是String的。</span><br><span class="hljs-comment">异常：</span><br><span class="hljs-comment">   可选项。</span><br><span class="hljs-comment">   省略时表示任意异常类型</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//service包下所有的类中以delete开始的所有方法</span><br>   execution(<span class="hljs-keyword">public</span> * com.powernode.service.*.delete*(..)) <br></code></pre></td></tr></table></figure><h3 id="Spring中对事务的控制"><a href="#Spring中对事务的控制" class="headerlink" title="Spring中对事务的控制"></a>Spring中对事务的控制</h3><h4 id="声明式事务（Transaction）"><a href="#声明式事务（Transaction）" class="headerlink" title="声明式事务（Transaction）"></a>声明式事务（Transaction）</h4><p><code>@Transaction</code> 注解的底层原理涉及到 Spring 框架的两个核心机制：AOP（面向切面编程）和事务管理。</p><p>当一个方法被 <code>@Transaction</code> 注解标注后，Spring 会使用 AOP 机制，将事务管理的逻辑从业务逻辑中分离出来，并动态地生成一个代理对象。代理对象会包装原始对象，并在原始对象的方法执行前后添加一些事务管理的逻辑，比如开启事务、提交事务或回滚事务等。</p><p>具体来说，Spring 通过使用 JDK 动态代理或 CGLIB（Code Generation Library）字节码生成技术，在运行时动态地生成代理对象。当一个被 <code>@Transaction</code> 注解标注的方法被调用时，实际上是调用了代理对象的方法。代理对象会在方法执行前后织入事务管理的逻辑，实现事务的自动管理。</p><p>当方法执行成功时，代理对象会提交事务，将数据库中的数据持久化。如果方法执行失败，代理对象会回滚事务，保证数据的一致性和完整性。</p><p>总之，<code>@Transaction</code> 注解的底层原理是通过 AOP 机制和事务管理机制相结合实现的。通过动态生成代理对象，在原始对象的方法执行前后添加事务管理的逻辑，从而实现了自动的事务管理。</p><h4 id="Spring中事务失效的情况"><a href="#Spring中事务失效的情况" class="headerlink" title="Spring中事务失效的情况"></a>Spring中事务失效的情况</h4><ol><li>方法没有被 Spring 托管：Spring 只能管理由 Spring 容器管理的 bean，如果一个方法不是由 Spring 容器管理的，那么 Spring 将无法管理它的事务，事务也就会失效。（非代理对象不会被Spring托管，所以非代理对象的事务也不会生效）</li><li>事务传播属性设置不当：事务传播属性可以控制事务在多个方法调用时的行为。如果事务传播属性设置不当，比如使用了 <code>Propagation.REQUIRES_NEW</code> 传播属性，那么将会导致当前事务挂起，新的事务被启动，从而导致事务失效。</li><li>异常没有被正确处理：Spring 的事务管理机制默认情况下只会对受检查的异常（Checked Exception）进行回滚操作。如果业务逻辑中抛出了未受检查的异常（Unchecked Exception）或 Error，而且没有正确地处理这些异常，那么就可能导致事务失效。</li><li>事务的边界设置不当：事务的边界应该设置在包含所有涉及到数据库操作的方法的最外层，如果事务的边界设置不当，可能会导致某些数据库操作没有被包含在事务中，从而导致事务失效。</li><li>数据库表引擎不支持事务：一些数据库表引擎，比如 MyISAM，不支持事务。如果在使用这些数据库表引擎的情况下尝试进行事务管理，那么事务将无法生效。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/07/19/hello-world/"/>
    <url>/2023/07/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Hello-Zyw"><a href="#Hello-Zyw" class="headerlink" title="Hello Zyw"></a>Hello Zyw</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><h3 id="那就从这里开始吧"><a href="#那就从这里开始吧" class="headerlink" title="那就从这里开始吧"></a>那就从这里开始吧</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
