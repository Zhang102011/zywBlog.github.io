<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java IO</title>
    <link href="/2023/07/21/Java%20IO/"/>
    <url>/2023/07/21/Java%20IO/</url>
    
    <content type="html"><![CDATA[<h2 id="常见的IO模型"><a href="#常见的IO模型" class="headerlink" title="常见的IO模型"></a>常见的IO模型</h2><ul><li>同步阻塞 I&#x2F;O</li><li>同步非阻塞 I&#x2F;O</li><li>多路复用I&#x2F;O</li><li>信号驱动 I&#x2F;O </li><li>异步 I&#x2F;O。</li></ul><h2 id="Java中常见的IO"><a href="#Java中常见的IO" class="headerlink" title="Java中常见的IO"></a>Java中常见的IO</h2><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I&#x2F;O)"></a>BIO (Blocking I&#x2F;O)</h3><p>BIO 属于同步阻塞 IO 模型 。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。<br><img src="/image/IO/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO.png"><br>BIO在连接数量不高时是没有问题的，但是如果连接数量太大，则会无能为力</p><h3 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking&#x2F;New I&#x2F;O)"></a>NIO (Non-blocking&#x2F;New I&#x2F;O)</h3><p>Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。NIO基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中或者从缓冲区写入到通道中。对于高负载、高并发的（网络）应用，应使用 NIO<br><img src="/image/IO/Java%E7%9A%84NIO%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png"><br>NIO和IO最大的区别就是，<strong>IO是面向流的、NIO是面向缓存区的</strong></p><p>从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送 数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从Buffer 中取出数据来处理<br><img src="/image/IO/NIO%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%9E%8B.png"></p><hr>NIO中的Channel我们称之为通道，它与Stream流比较类似，只不过Stream流是单向的只能读，而Channel是双向的，可读可写<hr><p><strong>我们重点来学习一下NIO中的Selector</strong></p><hr>Selector 能够检测多个注册的通道上是否有事件发生，如果有事 件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可 以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -> 用户空间）还是阻塞的<h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I&#x2F;O)"></a>AIO (Asynchronous I&#x2F;O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步IO模型。异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><strong>BIO、NIO、AIO之间的关系</strong><br><img src="/image/IO/BIO%E3%80%81NIO%E3%80%81AIO%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2023/07/21/SQL/"/>
    <url>/2023/07/21/SQL/</url>
    
    <content type="html"><![CDATA[<h2 id="group-concat函数"><a href="#group-concat函数" class="headerlink" title="group-concat函数"></a>group-concat函数</h2><p><code>GROUP_CONCAT</code> 函数是一种在关系型数据库中用于合并（连接）多行数据的聚合函数。它常常与 <code>GROUP BY</code> 子句一起使用，用于将同一组的多行数据合并成单一的字符串值 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ClassId, GROUP_CONCAT(StudentName) <span class="hljs-keyword">AS</span> Students<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ClassId;<br><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+-----------------------------+</span><br><span class="hljs-operator">|</span> ClassId <span class="hljs-operator">|</span> Students                    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+-----------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1</span>       <span class="hljs-operator">|</span> John, Alice, Bob            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">2</span>       <span class="hljs-operator">|</span> Mary, James                 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3</span>       <span class="hljs-operator">|</span> Sarah, Michael, Jessica     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+-----------------------------+</span><br><br></code></pre></td></tr></table></figure><p> 上面的 SQL 查询将根据 <code>ClassId</code> 列对学生数据进行分组，并使用 <code>GROUP_CONCAT</code> 函数将同一班级的学生姓名合并成一个字符串，并以逗号分隔各个姓名 </p><h2 id="列转行、行转列"><a href="#列转行、行转列" class="headerlink" title="列转行、行转列"></a>列转行、行转列</h2><p>列转行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> product_id, <span class="hljs-string">&#x27;store1&#x27;</span> store, store1 price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> store1 <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> product_id, <span class="hljs-string">&#x27;store2&#x27;</span> store, store2 price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> store2 <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> product_id, <span class="hljs-string">&#x27;store3&#x27;</span> store, store3 price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> store3 <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><p>行转列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>  product_id,<br>  <span class="hljs-built_in">SUM</span>(IF(store <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;store1&#x27;</span>, price, <span class="hljs-keyword">NULL</span>)) <span class="hljs-string">&#x27;store1&#x27;</span>,<br>  <span class="hljs-built_in">SUM</span>(IF(store <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;store2&#x27;</span>, price, <span class="hljs-keyword">NULL</span>)) <span class="hljs-string">&#x27;store2&#x27;</span>,<br>  <span class="hljs-built_in">SUM</span>(IF(store <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;store3&#x27;</span>, price, <span class="hljs-keyword">NULL</span>)) <span class="hljs-string">&#x27;store3&#x27;</span> <br><span class="hljs-keyword">FROM</span><br>  Products1 <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> product_id ;<br></code></pre></td></tr></table></figure><h2 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">where</span> mail REGEXP <span class="hljs-string">&#x27;^[a-zA-Z][a-zA-Z0-9\_\.\-]*@leetcode\.com$&#x27;</span><br>要用到关键字 REGEXP<br></code></pre></td></tr></table></figure><h2 id="筛选时间"><a href="#筛选时间" class="headerlink" title="筛选时间"></a>筛选时间</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">对年份的筛选:<span class="hljs-number">2020</span>年（月日同理）<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">year</span>(time_stamp) <span class="hljs-operator">=</span> <span class="hljs-number">2020</span> <br><span class="hljs-keyword">where</span> time_stamp <span class="hljs-keyword">like</span> &quot;2020%&quot;<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">LEFT</span>(time_stamp, <span class="hljs-number">4</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2020&#x27;</span><br><span class="hljs-keyword">where</span> substr(time_stamp,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2020&#x27;</span><br>datediff(time_stamp, <span class="hljs-string">&#x27;2020-01-01&#x27;</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> datediff(time_stamp, <span class="hljs-string">&#x27;2020-12-31&#x27;</span>) <span class="hljs-operator">&lt;=</span> <span class="hljs-number">0</span> <br><span class="hljs-keyword">where</span> time_stamp <span class="hljs-keyword">between</span> <span class="hljs-string">&#x27;2020-01-01 00:00:00&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;2020-12-31 23:59:59&#x27;</span><br><span class="hljs-keyword">where</span>(time_stamp <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2020-01-01 00:00:00&#x27;</span> <span class="hljs-keyword">and</span> time_stamp <span class="hljs-operator">&lt;=</span> <span class="hljs-string">&#x27;2020-12-31 23:59:59&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在使用between来限定时间时，默认会进行格式化，格式化为 00:00:00，23:59:59</p><h2 id="CASE-WHEN使用"><a href="#CASE-WHEN使用" class="headerlink" title="CASE WHEN使用"></a>CASE WHEN使用</h2><ol><li>简单的 CASE WHEN：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> column1,<br>       column2,<br>       <span class="hljs-keyword">CASE</span> column3<br>           <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Apple&#x27;</span><br>           <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;B&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Banana&#x27;</span><br>           <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;C&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Cherry&#x27;</span><br>           <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;Unknown&#x27;</span><br>       <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> column3_alias<br><span class="hljs-keyword">FROM</span> table_name;<br><br></code></pre></td></tr></table></figure><p>2.搜索条件中带有运算符的 CASE WHEN：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> column1,<br>       column2,<br>       <span class="hljs-keyword">CASE</span><br>           <span class="hljs-keyword">WHEN</span> column3 <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Positive&#x27;</span><br>           <span class="hljs-keyword">WHEN</span> column3 <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Negative&#x27;</span><br>           <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;Zero&#x27;</span><br>       <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> column3_status<br><span class="hljs-keyword">FROM</span> table_name;<br><br></code></pre></td></tr></table></figure><h2 id="IFNULL函数"><a href="#IFNULL函数" class="headerlink" title="IFNULL函数"></a>IFNULL函数</h2><p>IFNULL() 函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值，如果不为 NULL 则返回第一个参数的值。</p><p>IFNULL() 函数语法格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">IFNULL(expression, alt_value)<br></code></pre></td></tr></table></figure><h2 id="窗口函数-DENSE-RANK"><a href="#窗口函数-DENSE-RANK" class="headerlink" title="窗口函数 DENSE_RANK()"></a>窗口函数 <code>DENSE_RANK()</code></h2><p><img src="/image/Database/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> score,<br><span class="hljs-built_in">dense_rank</span>() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;Rank&#x27;</span><br><span class="hljs-keyword">from</span> Scores<br><br><span class="hljs-built_in">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;Rank&#x27;</span>：这是一个窗口函数 <span class="hljs-built_in">DENSE_RANK</span>()，它计算在分数列上的密集排名。使用 <span class="hljs-keyword">OVER</span>() 子句指定排序顺序，这里是按照分数列降序排列。<span class="hljs-built_in">DENSE_RANK</span>() 函数将为每个分数分配一个排名值，相同的分数将获得相同的排名值。<br></code></pre></td></tr></table></figure><h2 id="数据库索引的失效"><a href="#数据库索引的失效" class="headerlink" title="数据库索引的失效"></a>数据库索引的失效</h2><ul><li>检索字段采用以“%”开头的模糊查询时索引会失效</li><li>使用OR时会失效，如果要使用OR那么OR两边的字段都必须有索引，索引才会生效。使用union，union不会让索引失效</li><li>使用复合索引时没有使用左侧的列查找，索引失效(违背了最左匹配原则)</li><li>当where当中索引列参加了运算，索引会失效</li><li>在where当中索引列使用了函数，索引失效</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2023/07/21/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/07/21/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="多态的执行顺序"><a href="#多态的执行顺序" class="headerlink" title="多态的执行顺序"></a>多态的执行顺序</h2><ul><li>多态中成员方法使用规则：编译看左边，运行看右边</li><li>多态中，子类重写的方法，当super调用就是调用父类方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//假定Base b = new Derived（）; 调用执行b.methodOne（）后，输出结果是什么？</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodOne</span><span class="hljs-params">()</span><br>   &#123;<br>      System.out.print(<span class="hljs-string">&quot;A&quot;</span>);   <span class="hljs-comment">//3.输出A</span><br>      methodTwo();             <span class="hljs-comment">//4.未被super调用，使用子类重写方法methodTwo()方法</span><br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodTwo</span><span class="hljs-params">()</span><br>   &#123;<br>      System.out.print(<span class="hljs-string">&quot;B&quot;</span>);  <span class="hljs-comment">//6.输出B</span><br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span><br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodOne</span><span class="hljs-params">()</span>     <span class="hljs-comment">//1</span><br>   &#123;<br>      <span class="hljs-built_in">super</span>.methodOne();       <span class="hljs-comment">//2.super调用，使用父类methodOne（）方法</span><br>      System.out.print(<span class="hljs-string">&quot;C&quot;</span>);<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodTwo</span><span class="hljs-params">()</span><br>   &#123;<br>      <span class="hljs-built_in">super</span>.methodTwo();       <span class="hljs-comment">//5.super调用，使用父类methodTwo()方法</span><br>      System.out.print(<span class="hljs-string">&quot;D&quot;</span>);   <span class="hljs-comment">//7.输出D</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="异常代码段中值的返回"><a href="#异常代码段中值的返回" class="headerlink" title="异常代码段中值的返回"></a>异常代码段中值的返回</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(test()); <span class="hljs-comment">//2</span><br> <br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(temp);  <span class="hljs-comment">//第一步：1</span><br>            <span class="hljs-keyword">return</span> ++temp; <span class="hljs-comment">//返回2，但不是直接返回，而是先放到临时空间中，等finally代码块代码执行完再返回</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(temp);<br>            <span class="hljs-keyword">return</span> ++temp;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ++temp;<br>            System.out.println(temp);  <span class="hljs-comment">//3</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> finally代码块在return中间执行。return的值会被放入临时空间，然后执行finally代码块，如果finally中有return，会刷新临时空间的值，方法结束返回临时空间值 </p><p>当出现多个catch块时，应该先处理小异常，再处理大异常，也就是把父类异常的catch块放到处理子类异常的catch块之后</p><h2 id="equals方法注意事项"><a href="#equals方法注意事项" class="headerlink" title="equals方法注意事项"></a>equals方法注意事项</h2><p>使用equals方法对对象内容进行比较时，要注意比较的双方应该是同一数据类型</p><p>在使用equals方法时要避免空指针异常</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>作用：将数据长久的保存在磁盘里面</p><p>方式：实现序列化接口： Serializable ，使用transient关键字修饰变量不能被序列化，static变量不管有没有加transient都不可以被序列化</p><h2 id="数据类型的转变"><a href="#数据类型的转变" class="headerlink" title="数据类型的转变"></a>数据类型的转变</h2><p>只要两个操作数中有一个是double类型的，另一个将会被转换成double类型，并且结果也是double类型，如果两个操作数中有一个是float类型的，另一个将会被转换为float类型，并且结果也是float类型，如果两个操作数中有一个是long类型的，另一个将会被转换成long类型，并且结果也是long类型，否则（操作数为：byte、short、int 、char），两个数都会被转换成int类型，并且结果也是int类型。 </p><p>在数据类型的转换中：由大到小需要强制转换，由小到大不需要</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li>构造方法的名字必须和类名一致</li><li>构造方法没有返回值，返回的是一个类，也不能用void修饰</li><li>构造方法不能是抽象的、静态的、最终的、同步的也就是说，他不能通过abstract、static、final、synchronized关键字修饰</li></ul><h2 id="实例变量、类变量、局部变量"><a href="#实例变量、类变量、局部变量" class="headerlink" title="实例变量、类变量、局部变量"></a>实例变量、类变量、局部变量</h2><p>实例变量： 也叫对象变量、类成员变量；从属于类由类生成对象时，才分配存储空间，各对象间的实例变量互不干扰，能通过对象的引用来访问实例变量 </p><p>类变量： 也叫静态变量，是一种比较特殊的实例变量，用static关键字修饰；一个类的静态变量，所有由这类生成的对象都共用这个类变量，类装载时就分配存储空间。一个对象修改了变量，则所以对象中这个变量的值都会发生改变。 </p><p>局部变量： 方法中或者某局部块中声明定义的变量或方法的参数被称为局部变量 </p><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><ul><li><p>接口是行为的抽象，是一种行为的规范，接口是like a的关系；抽象是对类的抽象，是一种模板设计，抽象类是is a的关系</p></li><li><p>接口没有构造方法，而抽象类有构造方法</p></li><li><p>接口可以多实现，但抽象类只能单继承</p></li><li><p>接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public abstract的。抽象类中成员变量默认是default，可在子类中被重新定义，也可以被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不能带花括号。</p><p>注：JDK1.8中对接口增加了新的特性</p></li><li><p>默认方法（default method）：JDK1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义的默认方法可以不被子类所实现，但只能被实现的子类的对象所调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；</p></li><li><p>静态方法（static method）：JDK1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）</p></li></ul><h2 id="GC垃圾回收器"><a href="#GC垃圾回收器" class="headerlink" title="GC垃圾回收器"></a>GC垃圾回收器</h2><p>垃圾回收器只针对Java堆进行垃圾回收， 堆用于存放所有对象，是线程共享的 </p><h2 id="Java程序初始化顺序"><a href="#Java程序初始化顺序" class="headerlink" title="Java程序初始化顺序"></a>Java程序初始化顺序</h2><ul><li>父类的静态代码块</li><li>子类的静态代码块</li><li>父类的普通代码块</li><li>父类的构造代码块</li><li>子类的普通代码块</li><li>子类的构造方法</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="2023-6-5"><a href="#2023-6-5" class="headerlink" title="2023.6.5"></a>2023.6.5</h1><h2 id="HTTP协议、TCP协议、UDP协议"><a href="#HTTP协议、TCP协议、UDP协议" class="headerlink" title="HTTP协议、TCP协议、UDP协议"></a>HTTP协议、TCP协议、UDP协议</h2><p> HTTP（Hypertext Transfer Protocol）是一种用于在Web浏览器和Web服务器之间传输数据的协议。它是一种无状态的、面向请求&#x2F;响应的协议，用于客户端和服务器之间的通信。  HTTP协议是基于TCP&#x2F;IP协议栈的<strong>应用层协议</strong>，通过在TCP连接上发送和接收HTTP报文来实现通信。它使用明文传输，不提供加密和身份验证，因此可以通过使用HTTPS（HTTP Secure）来提供加密和安全性。 </p><p>TCP是一种<strong>面向连接</strong>的、可靠的<strong>传输层协议</strong>，它负责将数据可靠地传输给目标主机。TCP提供了数据分段、重传、流量控制和拥塞控制等功能，以确保数据的可靠传输。当使用HTTP时，HTTP请求和响应数据被分割成多个TCP段，然后通过TCP连接传输。</p><p>UDP是一种<strong>面向无连接</strong>的传输层协议，它不保证数据的可靠传输。UDP更注重传输效率和速度，适用于那些对数据传输的实时性要求较高的应用场景。与TCP不同，UDP不提供可靠性和流量控制等功能。由于HTTP需要可靠性，因此很少直接使用UDP作为传输层协议，而是使用TCP来传输HTTP数据。</p><p> HTTP协议使用TCP作为底层传输协议，以实现可靠的数据传输。TCP负责将HTTP请求和响应分割成数据段，并在网络上将它们传输到目标主机。UDP则通常不直接用于HTTP通信，因为它不提供可靠性保证 </p><h2 id=""><a href="#" class="headerlink" title="&lt;&lt;和&gt;&gt;"></a>&lt;&lt;和&gt;&gt;</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">100</span>&gt;&gt;<span class="hljs-number">3</span> 等价于 <span class="hljs-number">100</span>*<span class="hljs-number">2</span>的三次方<br><span class="hljs-attribute">100</span>&lt;&lt;<span class="hljs-number">3</span> 等价于 <span class="hljs-number">100</span>/<span class="hljs-number">2</span>的三次方<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程</title>
    <link href="/2023/07/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/07/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Java多线程设计模式"><a href="#Java多线程设计模式" class="headerlink" title="Java多线程设计模式"></a>Java多线程设计模式</h2><h3 id="顺序、并发与并行"><a href="#顺序、并发与并行" class="headerlink" title="顺序、并发与并行"></a>顺序、并发与并行</h3><p>顺序：表示多个操作“依次处理”</p><p>并行：表示多个操作“同时处理”</p><p>并发：表示多个操作“间隔进行”</p><p> 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的。 </p><p> 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。 </p><h3 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h3><p><strong>开启多线程的方法是start()而不是run()</strong></p><h4 id="利用Thread类的子类的实例启动线程"><a href="#利用Thread类的子类的实例启动线程" class="headerlink" title="利用Thread类的子类的实例启动线程"></a>利用Thread类的子类的实例启动线程</h4><p>创建一个继承自Thread类的子类，并重写其run()方法。在run()方法中定义线程要执行的代码。然后创建该子类的实例，并调用start()方法启动线程。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程执行的代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="利用Runnable接口的实现类的实例启动线程"><a href="#利用Runnable接口的实现类的实例启动线程" class="headerlink" title="利用Runnable接口的实现类的实例启动线程"></a>利用Runnable接口的实现类的实例启动线程</h4><p>创建一个实现Runnable接口的类，并实现其run()方法。在run()方法中定义线程要执行的代码。然后创建该类的实例，并将其作为参数传递给Thread类的构造函数，最后调用start()方法启动线程。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程执行的代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>        thread.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Thread类本身还实现了Runnable接口，并且持有run方法，但Thread类的run方法主体是空的，不执行任何操作。</p><h4 id="java-util-concurrent-ThreadFactory中的线程创建"><a href="#java-util-concurrent-ThreadFactory中的线程创建" class="headerlink" title="java.util.concurrent.ThreadFactory中的线程创建"></a>java.util.concurrent.ThreadFactory中的线程创建</h4><p>java.util.concurrent包中包含一个将线程创建抽象化的ThreadFactory接口。利用该接口，我们可以将Runnable作为参数并通过new创建Thread实例的处理隐藏在ThreadFactory内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建线程工厂</span><br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> Executors.defaultThreadFactory();<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread running: &quot;</span> + Thread.currentThread().getName());<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> threadFactory.newThread(task);<br>        thread.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="线程的暂停"><a href="#线程的暂停" class="headerlink" title="线程的暂停"></a>线程的暂停</h3><p>线程Thread类中的sleep方法能够暂停线程运行。sleep方法是Thread类的静态方法</p><p><img src="/image/GUI/sleep%E6%96%B9%E6%B3%95.png"></p><h3 id="线程的互斥"><a href="#线程的互斥" class="headerlink" title="线程的互斥"></a>线程的互斥</h3><h4 id="synchronized方法"><a href="#synchronized方法" class="headerlink" title="synchronized方法"></a>synchronized方法</h4><p>如果声明一个方法时，在前面加上关键字synchronized，那么这个方法每次就只能由一个线程运行。这种方法称为synchronized方法，有时也称为同步方法</p><p><img src="/image/GUI/synchronized1.png"></p><p><img src="/image/GUI/synchronized2.png"></p><p><img src="/image/GUI/synchronized3.png"></p><p>每一个实例拥有一个独立的锁。因此，并不是说某一个实例中synchronized方法正在执行中，其他实例中的synchronized方法就不可以运行了</p><p>synchronized方法与synchronized代码块</p><p><img src="/image/GUI/synchronized%E6%96%B9%E6%B3%95.png"></p><h3 id="线程的协作"><a href="#线程的协作" class="headerlink" title="线程的协作"></a>线程的协作</h3><p>Java提供了用于执行线程控制的wait方法、notify方法和notifyAll方法。wait是让线程等待的方法，而notify方法和notifyAll方法是唤醒等待中的线程的方法</p><h5 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h5><p>所有实例都拥有一个等待队列，它是在实例的wait方法执行后停止操作的线程的队列。</p><p>执行wait方法后，线程便会暂停操作，进入等待队列这个休息室。除非发生以下情况，否则线程会一直在等待队列中休眠</p><ul><li><p>有其他线程的notify方法来唤醒线程</p></li><li><p>有其他线程的notifyAll方法来唤醒线程</p></li><li><p>有其他线程的interrupt方法来唤醒线程</p></li><li><p>wait方法超时</p><p>wait方法：</p><p><img src="/image/GUI/wait%E6%96%B9%E6%B3%95.png"></p></li></ul><p>notify方法：</p><p><img src="/image/GUI/notify%E6%96%B9%E6%B3%95.png"></p><p>notify方法唤醒的线程并不会在执行notify的一瞬间重新运行。因为在执行notify的那一瞬间，执行notify方法的线程还持有着锁，所以其他线程还无法获取这个实例的锁</p><p>notifyAll方法：</p><p><img src="/image/GUI/notifyAll%E6%96%B9%E6%B3%95.png"></p><h3 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h3><ol><li>悲观锁（Pessimistic Locking）：悲观锁假设在并发环境中会出现频繁的冲突，因此在访问共享资源之前会将其加锁，确保同一时间只有一个线程可以访问。Java中的synchronized关键字和ReentrantLock就是悲观锁的实现。</li><li>乐观锁（Optimistic Locking）：乐观锁认为在并发环境中冲突的概率较低，因此不立即加锁，而是在更新资源时进行冲突检测。如果检测到冲突，乐观锁会进行回退并重试，直到没有冲突为止。Java中的StampedLock是一种乐观锁的实现。</li><li>自旋锁（Spin Lock）：如果持有锁的线程在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态的切换进入阻塞挂起状态，他们只需要等一等，等待持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗，但是也加大了CPU资源的浪费</li></ol><h3 id="线程的阻塞状态"><a href="#线程的阻塞状态" class="headerlink" title="线程的阻塞状态"></a>线程的阻塞状态</h3><ol><li>等待阻塞（o.wait-&gt;等待队列）</li><li>同步阻塞（lock-&gt;锁池）运行的线程在获取对象的同步锁时，若该同步线程被别的线程占用，则JVM会把该线程放到锁池中</li><li>其他阻塞（sleep&#x2F;join）</li></ol><h3 id="线程的死亡"><a href="#线程的死亡" class="headerlink" title="线程的死亡"></a>线程的死亡</h3><ol><li>正常死亡：run（）或call（）方法执行完成，线程正常结束</li><li>异常结束：线程抛出一个未捕获的Exception或Error</li><li>调用stop：直接调用该线程的stop方法来结束线程——该方法通常容易导致死锁</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++基础知识</title>
    <link href="/2023/07/20/C++/"/>
    <url>/2023/07/20/C++/</url>
    
    <content type="html"><![CDATA[<h2 id="指针、常量指针、指针常量的区别"><a href="#指针、常量指针、指针常量的区别" class="headerlink" title="指针、常量指针、指针常量的区别"></a>指针、常量指针、指针常量的区别</h2><p>指针：可以改变它所指向的内存区域里面的值，同时也可以指向其他的内存区域</p><p>常量指针：所指向的内存地址可以发生改变，但不能改变该内存区域里面的值</p><p>指针常量：指向的内存地址不可变，但内存地址中存入的数据可以发生改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> j=<span class="hljs-number">20</span>;<br><span class="hljs-comment">//指针</span><br><span class="hljs-type">int</span>* pi=&amp;i;<br>pi=&amp;j  <span class="hljs-comment">//true</span><br>*pi=<span class="hljs-number">20</span>;<span class="hljs-comment">//true</span><br><span class="hljs-comment">//常量指针</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* pi=&amp;i;<br>pi=&amp;j  <span class="hljs-comment">//true</span><br>*pi=<span class="hljs-number">20</span>;<span class="hljs-comment">//false</span><br><span class="hljs-comment">//指针常量</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> pi=&amp;i;<br>pi=&amp;j; <span class="hljs-comment">//false</span><br>*pi=<span class="hljs-number">20</span>;<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="指针数组和数组指针的区别"><a href="#指针数组和数组指针的区别" class="headerlink" title="指针数组和数组指针的区别"></a>指针数组和数组指针的区别</h2><p>指针数组：数组</p><p>数组指针：指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>* pa[<span class="hljs-number">5</span>];  <span class="hljs-comment">//指针数组</span><br><span class="hljs-built_in">int</span>(*ap)[<span class="hljs-number">5</span>]; <span class="hljs-comment">//数组指针</span><br><br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>pa[<span class="hljs-number">0</span>] = arr;<br>cout &lt;&lt; <span class="hljs-string">&quot;pa[0]=&quot;</span> &lt;&lt; pa[<span class="hljs-number">0</span>] &lt;&lt; endl;   <span class="hljs-comment">//arr数组的内存地址也就是arr[0]的内存地址</span><br>cout &lt;&lt; <span class="hljs-string">&quot;*pa[0]=&quot;</span> &lt;&lt; *pa[<span class="hljs-number">0</span>] &lt;&lt; endl; <span class="hljs-comment">//arr[0]的值：1</span><br><br>ap = &amp;arr;<br>cout &lt;&lt; <span class="hljs-string">&quot;(*ap)=&quot;</span> &lt;&lt; *ap &lt;&lt; endl;    <span class="hljs-comment">//arr的内存地址</span><br>cout &lt;&lt; <span class="hljs-string">&quot;(*ap)[0]=&quot;</span> &lt;&lt; **ap &lt;&lt; endl; <span class="hljs-comment">//1</span><br>cout &lt;&lt; <span class="hljs-string">&quot;(*ap)[1]=&quot;</span> &lt;&lt; *(*ap+<span class="hljs-number">1</span>) &lt;&lt; endl; <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><h2 id="引用和常量引用"><a href="#引用和常量引用" class="headerlink" title="引用和常量引用"></a>引用和常量引用</h2><p>常量引用的值不能被修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> j=<span class="hljs-number">20</span>;<br><span class="hljs-type">int</span>&amp; ref=i;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; cref1=i;<span class="hljs-comment">//true</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; cref2=<span class="hljs-number">10</span>;<span class="hljs-comment">//true</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; cref3=j;<span class="hljs-comment">//true</span><br><br>ref=<span class="hljs-number">20</span>;   <span class="hljs-comment">//true</span><br>cref1=<span class="hljs-number">20</span>;  <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h2 id="引用和指针常量"><a href="#引用和指针常量" class="headerlink" title="引用和指针常量"></a>引用和指针常量</h2><p>相同点：在功能上它们是类似的</p><p>不同点：引用只是给变量起了一个别名，不会占用内存空间，但指针常量会占用内存空间</p><h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    num++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">increment</span>(value);<br>    <span class="hljs-comment">// value仍然为5，没有改变</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>值传递是指将函数参数的值复制一份传递给函数。在函数内部，对参数进行修改不会影响到原始的变量<br><span class="hljs-comment">//引用传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; num)</span> </span>&#123;<br>    num++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">increment</span>(value);<br>    <span class="hljs-comment">// value现在为6，被函数修改了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>引用传递是通过传递参数的引用而不是复制值来传递参数。这样，在函数内部对参数进行的修改会直接影响到原始变量<br></code></pre></td></tr></table></figure><h2 id="尾置返回类型"><a href="#尾置返回类型" class="headerlink" title="尾置返回类型"></a>尾置返回类型</h2><p>采用尾置返回类型的方法返回一个数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">createArray</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">int</span>* </span>&#123;<br>    <span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];  <span class="hljs-comment">// 创建一个包含5个整数的数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        arr[i] = i + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 初始化数组元素</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;  <span class="hljs-comment">// 返回数组指针</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">createArray</span>();  <span class="hljs-comment">// 调用函数并接收返回的数组指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        std::cout &lt;&lt; result[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出数组元素</span><br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] result;  <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello JVM</title>
    <link href="/2023/07/19/JVM/"/>
    <url>/2023/07/19/JVM/</url>
    
    <content type="html"><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="/image/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>程序计数器（Program Counter Register）可以看作是当前线程所执行的字节码的行号指示器</p><p><img src="/image/JVM/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.png"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>线程私有</li><li>不会存在内存溢出</li></ul><p>Java虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存</p><h2 id="JAVA虚拟机栈"><a href="#JAVA虚拟机栈" class="headerlink" title="JAVA虚拟机栈"></a>JAVA虚拟机栈</h2><p>与程序计数器一样，JAVA虚拟机栈也是线程私有的，它的生命周期与线程相同</p><p><img src="/image/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png"></p><p>每个方法被执行的时候，JAVA虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</p><p>垃圾回收是不涉及栈内存的</p><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>不共享变量不存在线程安全问题，共享变量存在线程安全问题，例如被static修饰的变量，在被多线程操作时就会出现线程安全问题</p><h3 id="内存溢出问题"><a href="#内存溢出问题" class="headerlink" title="内存溢出问题"></a>内存溢出问题</h3><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</p><p><img src="/image/JVM/StackOverflowError.png"></p><p>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常</p><p>虚拟机栈为虚拟机执行java方法（也就是字节码）服务，而本地方发栈则是为虚拟机使用到的本地方法（Native）服务</p><h2 id="Java堆（Java-Heap）"><a href="#Java堆（Java-Heap）" class="headerlink" title="Java堆（Java Heap）"></a>Java堆（Java Heap）</h2><p>Java堆(Java Heap)是虚拟机所管理内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例、</p><h3 id="内存溢出问题-1"><a href="#内存溢出问题-1" class="headerlink" title="内存溢出问题"></a>内存溢出问题</h3><p>Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”。Java堆他存在垃圾回收，但是也存在着内存溢出的问题。当新产生的对象要依赖于旧对象时，旧对象就不能被垃圾回收，如果数据量比较大，则可能存在内存溢出的问题</p><p><img src="/image/JVM/%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.png"></p><p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（TLAB），以提升对象分配时的效率。将Java堆细分的目的只是为了更好的回收内存，或者更快的分配内存</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态常量、即时编译器编译后的代码缓存等数据。</p><p><img src="/image/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E7%BB%93%E6%9E%84.png"></p><h2 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h2><p>运行时常量池是方法区的一部分</p><p>常量池表用于存放编译期生成的各种字面量与符号引用，这部分内容将在<strong>类加载后</strong>存放带方法区的运行时常量池中</p><p>运行时常量池相对于Class文件常量池的另外一个重要的特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，通过String类的intern（）方法可以将运行期间产生的常量放入池中</p><p>intern()这个方法在JDK1.6与JDK1.8有着区别：在JDK1.6中此方法将常量放入池中时会复制一份该常量，将复制的副本放入常量池中。然而在JDK1.8后放入的是该常量本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">String s1=<span class="hljs-string">&quot;a&quot;</span>;<br>String s2=<span class="hljs-string">&quot;b&quot;</span>;<br>String s3=<span class="hljs-string">&quot;ab&quot;</span>;<br>String s4=s1+s2;<span class="hljs-comment">//new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()==new String(&quot;ab&quot;)</span><br>String s5=<span class="hljs-string">&quot;a&quot;</span>+<span class="hljs-string">&quot;b&quot;</span>;<span class="hljs-comment">//s3==s5,直接在字符串池中找到&quot;ab&quot;,并不是分别找到&quot;a&quot;，&quot;b&quot;将其拼接</span><br></code></pre></td></tr></table></figure><h2 id="字符串池（StringTable）"><a href="#字符串池（StringTable）" class="headerlink" title="字符串池（StringTable）"></a>字符串池（StringTable）</h2><h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><ul><li><h3 id="调整虚拟机参数-XX-StringTableSize"><a href="#调整虚拟机参数-XX-StringTableSize" class="headerlink" title="调整虚拟机参数-XX:StringTableSize"></a>调整<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>参数-XX:StringTableSize</h3></li><li><h3 id="考虑将字符串入池"><a href="#考虑将字符串入池" class="headerlink" title="考虑将字符串入池"></a>考虑将字符串入池</h3></li></ul><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><h3 id="字符串池中的对象也会被垃圾回收器回收"><a href="#字符串池中的对象也会被垃圾回收器回收" class="headerlink" title="字符串池中的对象也会被垃圾回收器回收"></a>字符串池中的对象也会被垃圾回收器回收</h3><h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><p>在JDK1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道与缓冲区的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后用过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制</p><p><img src="/image/JVM/%E6%99%AE%E9%80%9A%E7%9A%84%E8%AF%BB%E5%8F%96%E6%96%B9%E5%BC%8F%E2%80%99.png"></p><p><img src="/image/JVM/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E2%80%98.png"></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="如何判断对象可以被回收"><a href="#如何判断对象可以被回收" class="headerlink" title="如何判断对象可以被回收"></a>如何判断对象可以被回收</h3><ol><li><p>引用计数算法：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的</p><p>缺点：难以解决对象之间相互循环引用的问题</p></li><li><p>可达性分析算法：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的</p><p><img src="/image/JVM/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png"></p><p>![](&#x2F;image&#x2F;JVM&#x2F;jvm\GC Roots.png)</p></li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><img src="/image/JVM/%E5%BC%95%E7%94%A8.png"></p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><ul><li>弱分代假说：绝大多数对象都是朝生夕灭的</li><li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡</li></ul><p><img src="/image/JVM/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png"></p><h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><ul><li><p>标记清除：Mark Sweep</p><p>速度较快，会造成内存碎片</p><p><img src="/image/JVM/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png"></p></li><li><p>标记整理算法：Mark Sweep</p><p>速度慢，不会产生内存碎片</p><p><img src="/image/JVM/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png"></p></li><li><p>复制算法：Copy</p><p>不会有内存碎片，需要占用双倍内存空间</p><p><img src="/image/JVM/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"></p></li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>串行：适用于单线程，堆内存较小 </p><p><img src="/image/JVM/%E4%B8%B2%E8%A1%8C.png"></p></li><li><p>吞吐量优先：适用于多线程，堆内存较大</p><p><img src="/image/JVM/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88.png">     </p></li><li><p>响应时间优先：适用于多线程，堆内存较大 </p><p><img src="/image/JVM/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88.png"></p></li></ul><h3 id="G1（Garbage-First）垃圾收集器"><a href="#G1（Garbage-First）垃圾收集器" class="headerlink" title="G1（Garbage First）垃圾收集器"></a>G1（Garbage First）垃圾收集器</h3><p>G1垃圾收集器它是里程石碑的垃圾收集器，它<strong>开创了面向局部收集的设计思路和基于Region内存布局形式</strong>。在JDK8Update40，G1收集器提供了并发的类卸载的支持，被Oracle公司认定为全功能的垃圾收集器</p><p>在规划JDK10的时候，HotSpot虚拟机提出了“统一垃圾收集器接口”，将内存回收的“行为”与“实现”进行分离，CMS以及其他收集器都重构成基于这套接口的一种实现（面向接口编程），这算是为CMS退出历史舞台铺下最后的道路</p><h4 id="G1收集器与CMS收集器的区别"><a href="#G1收集器与CMS收集器的区别" class="headerlink" title="G1收集器与CMS收集器的区别"></a>G1收集器与CMS收集器的区别</h4><p>CMS收集器：垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）</p><p>G1收集器：跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set）进行回收，衡量标准不再是它属于那个分代，而是那块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式</p><p>能够实现这一目标的关键是G1开创的基于Region的堆内存布局,G1不在坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</p><h4 id="Humongous区域"><a href="#Humongous区域" class="headerlink" title="Humongous区域"></a>Humongous区域</h4><p>专门存储大对象，G1认为只要大小超过一个Region容量一半的对象即可判定为大对象。对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</p><h4 id="G1收集器高效率"><a href="#G1收集器高效率" class="headerlink" title="G1收集器高效率"></a>G1收集器高效率</h4><p><img src="/image/JVM/G1%E6%94%B6%E9%9B%86%E5%99%A8%E9%AB%98%E6%95%88%E7%8E%87.png"></p><h4 id="G1在开发过程中的问题和解决方案"><a href="#G1在开发过程中的问题和解决方案" class="headerlink" title="G1在开发过程中的问题和解决方案"></a>G1在开发过程中的问题和解决方案</h4><ul><li>Region中存在跨Region引用对象如何解决</li></ul><p>  使用记忆集避免全堆作为GC Roots扫描，G1记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号，它是一种“双向”的卡表结构（卡表是：我指向谁，这种结构还记录了谁指向我）</p><ul><li><p>在并发标记阶段如何保证收集线程和用户线程互不干扰地进行</p><p><img src="/image/JVM/G1%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98.png"></p></li><li><p>如何建立起可靠的停顿预测模型</p><p>以衰减均值为理论基础来实现的</p></li></ul><h4 id="G1收集器的运作过程"><a href="#G1收集器的运作过程" class="headerlink" title="G1收集器的运作过程"></a>G1收集器的运作过程</h4><p>在不计算用户线程运行过程</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选标记</li></ul><p><img src="/image/JVM/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>可以由用户指定期望的停顿时间是G1收集器很强大的一个功能，设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。但是如果我们把停顿时间调的非常低，很有可能出现的结果就是由于停顿时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集器收集的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积</p><h4 id="为什么说G1是垃圾收集器技术发展的一个里程碑"><a href="#为什么说G1是垃圾收集器技术发展的一个里程碑" class="headerlink" title="为什么说G1是垃圾收集器技术发展的一个里程碑"></a>为什么说G1是垃圾收集器技术发展的一个里程碑</h4><p>从G1开始最先进的垃圾收集器设计导向都不约而同地变为追求能够应付应用的内存分配速率，而不追求一次把 整个Java堆全部清理干净。这样，应用在分配，同时收集器在收集，只要收集的速度能跟上对象分配的速度，那一切就可以运作得很完美</p><h4 id="G1收集器和CMS收集器的优缺点"><a href="#G1收集器和CMS收集器的优缺点" class="headerlink" title="G1收集器和CMS收集器的优缺点"></a>G1收集器和CMS收集器的优缺点</h4><p><img src="/image/JVM/G1%E5%92%8CCMS%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png"></p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>定义：Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称为虚拟机的类加载机制</p><h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p><img src="/image/JVM/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这个顺序按部就班的开始，而解析阶段则不一定：它在某些情况下可以在初始化后开始，这是为了支持Java语言的运行时绑定特性。请注意这里说的是各阶段按部就班的开始，而不是按部就班的进行，言下之意就是不是等一个阶段结束在进行下一个阶段，而是有可能两个阶段交叉相互执行</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载阶段，Java虚拟机需要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ol><p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，任然属于连接阶段的一部分，这两个阶段的开始时间任然保持着固定的先后顺序</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全</p><p>验证阶段大致上会完成下面四个阶段的验证动作：</p><ol><li><p>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</p><p>目的：保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求</p></li><li><p>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求</p><p>目的：对类的元数据信息进行语义校验</p></li><li><p>字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为</p></li><li><p>符号引用验证：此验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中各种符号引用）的各类信息进行匹配性校验，也就是该类是否缺少活着被禁止访问它依赖的某些外部类、方法、字段等资源</p><p>目的：确保解析阶段可以正常进行</p></li></ol><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段（在方法区中来分配内存，值得注意的是在JDK7之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK8及之后，类变量则会随着class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了）</p><p>在准备阶段进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配到Java堆中</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化阶段是类加载过程中的最后一个步骤。进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以说初始化阶段就是执行类构造器clinit()方法的过程</p><p>clinit()方法：</p><p>此方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(statin{}块)中的语句合并产生的，clinit()方法与类的构造函数（即在虚拟机视角中的实例构造器init()方法）不同，它不需要显示地调用父类构造器，Java虚拟机会保证在子类的clinit（）方法执行前，父类的clinit()方法已经执行完毕。所以在Java虚拟机中第一个被执行的linit()方法的类型肯定是java.lang.Object</p><p>由于父类的clinit()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</p><p>clinit()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成clinit()方法</p><p>Java虚拟机必须保证一个类的clinit()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的clinit()方法，其他线程都需要阻塞等待。直到活动线程执行完毕clinit()方法</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）</p><p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的加载器不同，那么这两个就必定不相等</p><p>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用了instanceof关键字做对象所属关系判定等各种情况</p><h2 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h2><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>Java内存模型的主要目的：定义程序中各种变量（能够被共享的变量）的访问规则，关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节</p><p>Java内存模型规定所有的变量都存储在主内存（在物理上它仅是虚拟机内存的一部分）中。每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的操作都必须在工作内存中进行，而不能直接读写主内存中的数据</p><p><img src="/image/JVM/%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png"></p><p>我们可以近似于把主内存和工作内存看成Java堆和虚拟机栈，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应虚拟机栈的部分区域，但是他们基本上是没有任何关系的</p><h4 id="内存的交互操作"><a href="#内存的交互操作" class="headerlink" title="内存的交互操作"></a>内存的交互操作</h4><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝带工作内存，如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下八种操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的</p><ul><li>lock（锁定）</li><li>unlock（解锁）</li><li>read（读取）</li><li>load（载入）</li><li>use（使用）</li><li>assign（赋值）</li><li>store（存储）</li><li>write（写入）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello Spring</title>
    <link href="/2023/07/19/Spring6/"/>
    <url>/2023/07/19/Spring6/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring6"><a href="#Spring6" class="headerlink" title="Spring6"></a>Spring6</h2><h3 id="OCP开闭原则"><a href="#OCP开闭原则" class="headerlink" title="OCP开闭原则"></a>OCP开闭原则</h3><p>对拓展开放，对修改关闭</p><h3 id="DIP依赖倒置原则"><a href="#DIP依赖倒置原则" class="headerlink" title="DIP依赖倒置原则"></a>DIP依赖倒置原则</h3><p>提倡面向抽象编程，面向接口编程，不要面向具体编程，让上层不再依赖下层</p><h3 id="IoC控制反转"><a href="#IoC控制反转" class="headerlink" title="IoC控制反转"></a>IoC控制反转</h3><p>控制反转（Inversion of Control)，是一种面向对象编程的设计思想，可以用来降低代码之间的耦合度，符合依赖倒置原则</p><p>核心思想：<strong>将对象创建的权利交出去，将对象和对象之间关系维护的管理权交出去，让第三方容器来负责创建和维护</strong></p><p>方式：依赖注入（DI）</p><h3 id="Spring8大模块"><a href="#Spring8大模块" class="headerlink" title="Spring8大模块"></a>Spring8大模块</h3><p>Spring5中加入了Spring WebFlux构成八大模块</p><ul><li>Spring Core模块：这是Spring框架最基础的部分，她提供了依赖注入特征来实现容器对Bean的管理。核心容器的主要组件是BeanFactory，BeanFactory是工厂模式的一个实现，是任何Spring的核心。它使用IoC将应用配置和依赖从实际的应用代码中分离出来</li><li>Spring Context模块：Spring上下文模块就是Spring成为框架的原因。这个模块拓展了BeanFactory。增加了对国际化消息、事件传播、验证的支持。</li><li>Spring AOP模块：面向切面编程</li><li>Spring DAO模块：提供了单独的支持JDBC操作的API</li><li>Spring ORM模块：Spring提供了ORM模块，也可以集成其他ORM，例如：MyBatis、Hibernate</li><li>Spring Web MVC模块：Spring为构建Web应用提供了一个功能全面的MVC框架。</li><li>Spring WebFlux模块</li><li>Spring Web模块</li></ul><h3 id="Spring特点"><a href="#Spring特点" class="headerlink" title="Spring特点"></a>Spring特点</h3><p>轻量、控制反转、面向切面、容器、框架</p><h3 id="set注入的实现原理"><a href="#set注入的实现原理" class="headerlink" title="set注入的实现原理"></a>set注入的实现原理</h3><p>通过反射机制调用该对象的set方法来给属性赋值，让两个对象之间产生关系</p><h3 id="简单类型包括"><a href="#简单类型包括" class="headerlink" title="简单类型包括"></a>简单类型包括</h3><ul><li>基本数据类型及其对应的包装类</li><li>String或其他的CharSequence子类</li><li>Number子类</li><li>Date子类</li><li>Enum子类</li><li>URL</li><li>URI</li><li>Temporal子类</li><li>Locale</li><li>Class</li></ul><p>如果我们把Date当做简单类型的话，日期字符串格式不能随便写。格式必须符合Date的toString（）方法的格式</p><h3 id="Bean对象的创建"><a href="#Bean对象的创建" class="headerlink" title="Bean对象的创建"></a>Bean对象的创建</h3><p>默认情况下Bean是单例的，此时Bean对象的创建是在初始化Spring上下文的时候完成的</p><p>当Bean是多例的时，Bean对象的创建是在调用getBean（）方法时创建，并且调用一次创建一次</p><h3 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h3><ul><li>singleton：默认的，单例</li><li>prototype：原型。每调用一次getBean（）方法则获取一个新的Bean对象。</li><li>request：一个请求对应一个Bean</li><li>session：一个对话一个Bean</li><li>global session：protlet应用中专用</li><li>application：一个应用一个Bean</li><li>websocket：一个websocket一个Bean</li><li>自定义scope</li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="工厂模式的三种形态："><a href="#工厂模式的三种形态：" class="headerlink" title="工厂模式的三种形态："></a>工厂模式的三种形态：</h4><ul><li>简单工厂模式：很多物品对应一个工厂，不属于23种设计模式</li><li>工厂方法模式：一个物品对应一个工厂</li><li>抽象工厂模式</li></ul><h3 id="Bean的实例化"><a href="#Bean的实例化" class="headerlink" title="Bean的实例化"></a>Bean的实例化</h3><p>Bean实例化的方式：</p><ul><li>通过构造方法实例化：调用对象的无参构造进行实例化</li><li>通过简单工厂实例化</li><li>通过factory-bean实例化</li><li>通过FactoryBean接口实例化</li></ul><p>factory-bean实例化和FactoryBean不一样。</p><p>1.写法不一样，前者是通过两个<bean/>实现,后者是通过实现FactoryBean接口实现。</p><p>2.实现时机不一样，前者是在创建spring容器时通过dom4j读取<bean/>标签中的内容创建。后者是在执行getBean()获取他时创建。</p><h3 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h3><p>BeanFactory：Spring IoC容器的顶级对象，BeanFactory被翻译为“Bean工厂”，在Spring的IoC中，“Bean工厂”负责创建Bean对象。BeanFactory是工厂</p><p>FactoryBean：它是一个Bean，是一个能够辅助Spring实例化其他Bean对象的一个Bean</p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p>以Bean生命周期之10步为例：</p><ul><li><p><strong>实例化Bean</strong>：调用无参数构造方法</p></li><li><p><strong>Bean属性赋值</strong>：调用set方法</p></li><li><p>检查Bean是否实现了Aware的相关接口，并设置相关依赖（BeanNameAware、BeanClassLoaderAware、BeanFactoryAware）如果要在实例化Bean时要执行某些代码就可以通过实现Aware接口来完成</p></li><li><p><strong>Bean后处理器before执行</strong></p></li><li><p>检查Bean是否实现了InitializingBean接口，并调用接口方法</p></li><li><p><strong>初始化Bean</strong>：调用init方法，这个init方法需要我们自己写</p></li><li><p><strong>Bean后处理器after执行</strong></p></li><li><p><strong>使用Bean</strong></p></li><li><p>检查Bean是否实现了DisposableBean接口，并调用接口方法</p></li><li><p><strong>销毁Bean</strong>：调用自己写的destory方法</p><p>如果你想在初始化前和初始化后添加代码，可以加入“Bean后处理器”。</p><p>编写一个类实现BeanPostProcessor类，并且重写before和after方法</p></li></ul><h3 id="自己new的对象如何让Spring管理"><a href="#自己new的对象如何让Spring管理" class="headerlink" title="自己new的对象如何让Spring管理"></a>自己new的对象如何让Spring管理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//自己new的对象</span><br>User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><span class="hljs-comment">//创建 默认可列表BeanFactory对象</span><br>DefaultListableBeanFactory factory=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span>();<br><span class="hljs-comment">//注册Bean</span><br>factory.registerSingleton(<span class="hljs-string">&quot;userBean&quot;</span>,user);<br><span class="hljs-comment">//从Spring中获取bean</span><br>User userBean=factory.getBean(<span class="hljs-string">&quot;userBean&quot;</span>,User.class);<br></code></pre></td></tr></table></figure><h3 id="Bean的循环依赖问题"><a href="#Bean的循环依赖问题" class="headerlink" title="Bean的循环依赖问题"></a>Bean的循环依赖问题</h3><h4 id="singleton-set注入下"><a href="#singleton-set注入下" class="headerlink" title="singleton+set注入下"></a>singleton+set注入下</h4><p>在此情况下循环依赖是没有问题的</p><h4 id="singleton-构造注入下"><a href="#singleton-构造注入下" class="headerlink" title="singleton+构造注入下"></a>singleton+构造注入下</h4><p>在此情况下是不能解决循环依赖问题，主要原因就是通过构造方法注入会导致实例化对象的过程和对象属性赋值的过程没有分离开，必须在一起完成导致的</p><h4 id="Spring解决循环依赖问题的机理"><a href="#Spring解决循环依赖问题的机理" class="headerlink" title="Spring解决循环依赖问题的机理"></a>Spring解决循环依赖问题的机理</h4><p>通过singleton+set注入这种方式，将实例化对象和给对象属性赋值分开完成</p><p>实例化Bean的时候：调用无参数构造方法来完成。<strong>此时可以先不给属性赋值，可以提前将该Bean对象“曝光”给外界</strong></p><p>给Bean属性赋值的时候：调用setter方法来完成</p><p>这两个步骤是完全分离开来完成</p><h3 id="Bean的缓存问题"><a href="#Bean的缓存问题" class="headerlink" title="Bean的缓存问题"></a>Bean的缓存问题</h3><p>Bean的三级缓存：</p><ul><li>一级缓存（单例对象的缓存）：key存储bean名称，value存储Bean对象</li><li>二级缓存（早期单例对象的缓存）：key存储bean名称，value存储早期的Bean</li><li>三级缓存（单例工厂缓存）：key存储bean名称，value存储该Bean的ObjectFactory对象</li></ul><p>在DefaultSingletonBeanRegistry类中有一个addSingletonFactory（）方法，这个方法的作用是：将创建Bean对象的ObjectFactory对象提前曝光</p><p><img src="/image/Spring6/image1.png"></p><p>从源码分析可知：</p><p><img src="/image/Spring6/image.png"></p><h3 id="声明Bean的注解"><a href="#声明Bean的注解" class="headerlink" title="声明Bean的注解"></a>声明Bean的注解</h3><ul><li>@Component</li><li>@Controller</li><li>@Service</li><li>@Repository</li></ul><p><img src="/image/Spring6/image2.png"></p><p>value是可以省略的，省略后默认名字是Bean类名首字母小写</p><h3 id="负责注入的注解"><a href="#负责注入的注解" class="headerlink" title="负责注入的注解"></a>负责注入的注解</h3><ul><li><p>@Value：简单类型进行注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.powernode.spring6.bean4;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@Value(value = &quot;zhangsan&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;20&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>@Autowired：默认通过类型自动装配</p></li><li><p>@Qualifier：中指定Bean名称</p><p>这两个注解要结合起来使用，@Autowired根据类型自动装配，@Qualifier根据名字进行自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.powernode.spring6.service;<br><br><span class="hljs-keyword">import</span> com.powernode.spring6.dao.UserDao;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;userDaoForOracle&quot;)</span> <span class="hljs-comment">// 这个是bean的名字。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>        userDao.insert();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Autowired注解可以出现在：属性上、构造方法上、构造方法的参数上、setter方法上</p><p>当带参数的构造方法只有一个，@Autowired可以省略</p><p>@Autowired注解默认根据类型注入。如果要根据名称注入的话，需要配合@Qualifier注解一起使用</p></li><li><p>@Resource</p><p>该注解是JDK扩展包中的，就是说是JDK的一部分，@Autowired是Spring框架自己的</p><p>@Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配</p><p>@Resource注解可以用到属性上、setter方法上</p></li></ul><h3 id="Spring的全注解式开发"><a href="#Spring的全注解式开发" class="headerlink" title="Spring的全注解式开发"></a>Spring的全注解式开发</h3><p>通过以下配置来代替xml文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&#123;&quot;com.powernode.spring6.da0&quot;,&quot;com.powernode.spring6.service&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Spring6Configuration</span>()&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>JDK动态代理：只能代理接口，<strong>通过反射机制来动态代理</strong></p><p>CGLIB动态代理：是一个强大的，高性能的，高质量的Code生成类库，它可以在运行期间扩展Java类与实现Java接口。它既可以代理接口也可以代理类，<strong>底层是通过继承的方式实现的</strong>。性能比JDK动态代理要好（底层是一个小而快的字节码处理框架ASM）</p><p>javassist动态代理：通过使用javassist对字节码操作作为JBoss实现动态“AOP”框架</p><h3 id="面向切面编程AOP"><a href="#面向切面编程AOP" class="headerlink" title="面向切面编程AOP"></a>面向切面编程AOP</h3><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>一般一个系统当中都会有一些系统服务，例如：日志、事务管理、安全等。这些系统服务被称为：<strong>交叉业务</strong></p><p>AOP：将于核心业务无关的代码独立的抽取出来，形成一个独立的组件，然后以横向交叉的方法应用到业务流程当中的过程被称为AOP</p><p><img src="/image/Spring6/image3.png"></p><h4 id="AOP的七大术语"><a href="#AOP的七大术语" class="headerlink" title="AOP的七大术语"></a>AOP的七大术语</h4><ul><li><p>连接点Joinpoint</p></li><li><p>切点Pointcut</p></li><li><p>通知Advice</p></li><li><p>切面Aspect</p><p>切面&#x3D;切点+通知</p></li><li><p>织入</p></li><li><p>代理对象</p></li><li><p>目标对象</p></li></ul><p><img src="/image/Spring6/image4.png"></p><h4 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">execution([访问控制权限修饰符] 返回值类型 [全限定类名] 方法名(形式参数列表) [异常])<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">访问控制权限修饰符：</span><br><span class="hljs-comment">   可选项。</span><br><span class="hljs-comment">   没写，就是4个权限都包括。</span><br><span class="hljs-comment">   写public就表示只包括公开的方法。</span><br><span class="hljs-comment">返回值类型：</span><br><span class="hljs-comment">   必填项。</span><br><span class="hljs-comment">   * 表示返回值类型任意。</span><br><span class="hljs-comment">全限定类名：</span><br><span class="hljs-comment">   可选项。</span><br><span class="hljs-comment">   两个点“..”代表当前包以及子包下的所有类。</span><br><span class="hljs-comment">   省略时表示所有的类。</span><br><span class="hljs-comment">方法名：</span><br><span class="hljs-comment">   必填项。</span><br><span class="hljs-comment">   *表示所有方法。</span><br><span class="hljs-comment">   set*表示所有的set方法。</span><br><span class="hljs-comment">形式参数列表：</span><br><span class="hljs-comment">   必填项</span><br><span class="hljs-comment">   () 表示没有参数的方法</span><br><span class="hljs-comment">   (..) 参数类型和个数随意的方法</span><br><span class="hljs-comment">   (*) 只有一个参数的方法</span><br><span class="hljs-comment">   (*, String) 第一个参数类型随意，第二个参数是String的。</span><br><span class="hljs-comment">异常：</span><br><span class="hljs-comment">   可选项。</span><br><span class="hljs-comment">   省略时表示任意异常类型</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//service包下所有的类中以delete开始的所有方法</span><br>   execution(<span class="hljs-keyword">public</span> * com.powernode.service.*.delete*(..)) <br></code></pre></td></tr></table></figure><h3 id="Spring中对事务的控制"><a href="#Spring中对事务的控制" class="headerlink" title="Spring中对事务的控制"></a>Spring中对事务的控制</h3><h4 id="声明式事务（Transaction）"><a href="#声明式事务（Transaction）" class="headerlink" title="声明式事务（Transaction）"></a>声明式事务（Transaction）</h4><p><code>@Transaction</code> 注解的底层原理涉及到 Spring 框架的两个核心机制：AOP（面向切面编程）和事务管理。</p><p>当一个方法被 <code>@Transaction</code> 注解标注后，Spring 会使用 AOP 机制，将事务管理的逻辑从业务逻辑中分离出来，并动态地生成一个代理对象。代理对象会包装原始对象，并在原始对象的方法执行前后添加一些事务管理的逻辑，比如开启事务、提交事务或回滚事务等。</p><p>具体来说，Spring 通过使用 JDK 动态代理或 CGLIB（Code Generation Library）字节码生成技术，在运行时动态地生成代理对象。当一个被 <code>@Transaction</code> 注解标注的方法被调用时，实际上是调用了代理对象的方法。代理对象会在方法执行前后织入事务管理的逻辑，实现事务的自动管理。</p><p>当方法执行成功时，代理对象会提交事务，将数据库中的数据持久化。如果方法执行失败，代理对象会回滚事务，保证数据的一致性和完整性。</p><p>总之，<code>@Transaction</code> 注解的底层原理是通过 AOP 机制和事务管理机制相结合实现的。通过动态生成代理对象，在原始对象的方法执行前后添加事务管理的逻辑，从而实现了自动的事务管理。</p><h4 id="Spring中事务失效的情况"><a href="#Spring中事务失效的情况" class="headerlink" title="Spring中事务失效的情况"></a>Spring中事务失效的情况</h4><ol><li>方法没有被 Spring 托管：Spring 只能管理由 Spring 容器管理的 bean，如果一个方法不是由 Spring 容器管理的，那么 Spring 将无法管理它的事务，事务也就会失效。（非代理对象不会被Spring托管，所以非代理对象的事务也不会生效）</li><li>事务传播属性设置不当：事务传播属性可以控制事务在多个方法调用时的行为。如果事务传播属性设置不当，比如使用了 <code>Propagation.REQUIRES_NEW</code> 传播属性，那么将会导致当前事务挂起，新的事务被启动，从而导致事务失效。</li><li>异常没有被正确处理：Spring 的事务管理机制默认情况下只会对受检查的异常（Checked Exception）进行回滚操作。如果业务逻辑中抛出了未受检查的异常（Unchecked Exception）或 Error，而且没有正确地处理这些异常，那么就可能导致事务失效。</li><li>事务的边界设置不当：事务的边界应该设置在包含所有涉及到数据库操作的方法的最外层，如果事务的边界设置不当，可能会导致某些数据库操作没有被包含在事务中，从而导致事务失效。</li><li>数据库表引擎不支持事务：一些数据库表引擎，比如 MyISAM，不支持事务。如果在使用这些数据库表引擎的情况下尝试进行事务管理，那么事务将无法生效。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/07/19/hello-world/"/>
    <url>/2023/07/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Hello-Zyw"><a href="#Hello-Zyw" class="headerlink" title="Hello Zyw"></a>Hello Zyw</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><h3 id="那就从这里开始吧"><a href="#那就从这里开始吧" class="headerlink" title="那就从这里开始吧"></a>那就从这里开始吧</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
