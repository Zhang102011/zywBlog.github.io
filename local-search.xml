<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>分布式系统</title>
    <link href="/2023/07/29/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/07/29/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="认识分布式系统"><a href="#认识分布式系统" class="headerlink" title="认识分布式系统"></a>认识分布式系统</h2><h3 id="什么是分布式系统"><a href="#什么是分布式系统" class="headerlink" title="什么是分布式系统"></a>什么是分布式系统</h3><p>分布式系统是一个其组件分布在不同的、联网的计算机上，组件之间通过传递消息进行通信和协议，共同完成一个任务的系统</p><h3 id="分布式系统的特点："><a href="#分布式系统的特点：" class="headerlink" title="分布式系统的特点："></a>分布式系统的特点：</h3><p>1、多进程，分布式系统中有多个进程并发运行<br>2、不共享操作系统，通过网络通信传递消息来协作<br>3、不共享时钟，所以很难通过时间定义两个事件的顺序</p><h3 id="为什么需要分布式系统"><a href="#为什么需要分布式系统" class="headerlink" title="为什么需要分布式系统"></a>为什么需要分布式系统</h3><p>1、高性能<br>2、可扩展性<br>3、高可用</p><h3 id="分布式系统的挑战"><a href="#分布式系统的挑战" class="headerlink" title="分布式系统的挑战"></a>分布式系统的挑战</h3><p>1、网络延迟问题：分布式系统中的多个节点通过网络进行通信’但网络并不能保证数据什么时候到达,以及 是否一定到达,有时网络甚至是不安全的。<br>2、部分失效问题：分布式系统中,系统可能会有＿部分节点正常工作,而另＿部分节点停止运行’或者 另一部分其实正常运行’但由于网络中断导致无法协同工作。系统的某些部分可能会以某种不<br>可预知的方式岩机’这被称为部分失效<br>3、时钟问题：在单机系统中’每个进程都有一个共同的时间,可以通过这个时间来调度进程从而表现出 同步行为°而在分布式系统中,每台机器都有自己的时钟,各个物理设备的本地时钟走时并不<br>准确,可能比其他机器稍快或更慢</p><h2 id="分布式系统模型"><a href="#分布式系统模型" class="headerlink" title="分布式系统模型"></a>分布式系统模型</h2><h3 id="网络链路模型"><a href="#网络链路模型" class="headerlink" title="网络链路模型"></a>网络链路模型</h3><p>在分布式系统中’网络出错常导致的问题称为网络分区（NetworkPartition）,网络分区是 指由于网络设备故障’导致网络分裂为多个独立的组。也就是节点仍然正常工作’但它们之间<br>的通信连接已经中断。通常我们谈论网络分区时,默认网络中断会存在一段时间<br>我们将发送者和接收者通信的网络链路分为以下几种:<strong>可靠链路（Reljable Link）</strong>、<strong>公平损失链路（FairˉLossLink）</strong>和<strong>任意链路（Arbitra1yLjnk）</strong></p><p><strong>可靠链路</strong>：可靠链路（ReljableLink）也称为完美链路（Pcr允c1Link）’是最容易编程的模型°完美链 路既不会丢失消息’也不会凭空捏造消息’但它可能对消息重新排序，每条消息最多传递一次</p><p><strong>公平损失链路</strong>：公平损失链路（FairˉLossLink）的消息可能会丢失、重复或重新排序’但消息最终总会到达因为消息会重复发送有限的次数</p><p><strong>任意链路</strong>：任意链路（ArbitraIyLmk）是最弱的—种网络链路模型。这种网络链路允许任意的网络链 路执行任何操作,可能有恶意软件修改网络数据包和流量</p><p>这三种网络模型是可以互相转换的。例如,对于公平损失链路’我们可以通过不断重传丢 失的消息,直到接收者收到它们’并让接收者过滤重复的消息,把一条公平损失链路变成-条 可靠链路。公正损失假设意味着任何网络分区（网络中断）只会持续有限的时间,不会永远持<br>续下去’所以我们可以保证每条消息最终都会被接收<br>使用加密技术可以将任意链路变成公平损失链路,例如我们常见的HTTPS中的“S”就使 用了TLS加密’可以防止黑客窃听和修改数据信息·但TLS加密并不能防止中间攻击人丢弃数 据包’因此,我们必须假设攻击人不会阻断通信链路’这样一条任意链路才能转换为公平损失链<br>路</p><h2 id="节点故障类型"><a href="#节点故障类型" class="headerlink" title="节点故障类型"></a>节点故障类型</h2><p><strong>崩溃-停止</strong>：指一个节点停止工作后永远不会恢复</p><p><strong>崩溃-恢复</strong>：允许节点重新启动并继续执行剩余的步骤</p><p><strong>拜占庭故障</strong>：如同拜占庭将军问题＿样’故障的节点可能不只会右机’还可能以任意方式 偏离算法,甚至恶意破坏系统</p><h2 id="按时间划分系统模型"><a href="#按时间划分系统模型" class="headerlink" title="按时间划分系统模型"></a>按时间划分系统模型</h2><p><strong>同步系统</strong>：一个消息的响应时间在一个有限且已知的时间范围内<br><strong>异步系统</strong>：一个消息的响应时间是无限的，无法知道一条消息什么时候会到达</p><h3 id="在分布式系统中如何解决消息重复消费的问题"><a href="#在分布式系统中如何解决消息重复消费的问题" class="headerlink" title="在分布式系统中如何解决消息重复消费的问题"></a>在分布式系统中如何解决消息重复消费的问题</h3><p>这个问题最常见的解决方法是使用幂等操作，幂等操作是指多从操作产生相同的结局，且不会有任何其他影响</p><p>然而，幂等操作会对系统进行严格的约束，我们总是无法准确知道另一端的结局是成功还是失败，我们只能一直等待确认请求，保证每个操作都是幂等的代价是昂贵的。在大多数情况下，<strong>我们可以给每条消息一个唯一的标识符</strong>，通过这种方式，接受者可以避免执行已经执行过的操作<br>很多时候，我们关心的是消息被处理的次数，而不是消息被送达的次数。尽可能做到精确处理一次消息，然后通过忽略后续重复的消息来达到看起来是精确一次的效果</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL存储引擎</title>
    <link href="/2023/07/29/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <url>/2023/07/29/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer</title>
    <link href="/2023/07/28/%E5%89%91%E6%8C%87Offer/"/>
    <url>/2023/07/28/%E5%89%91%E6%8C%87Offer/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><code>String</code>的一些<a href="https://www.runoob.com/java/java-string.html">常用方法</a><br><code>StringBuilder</code>的一些<a href="https://www.runoob.com/java/java-stringbuffer.html">常用方法</a></p><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p>请实现一个函数，把字符串s中每一个空格替换成“%20”</p><p>示例：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">输入：s = <span class="hljs-string">&quot;We are happy.&quot;</span><br>输出：<span class="hljs-string">&quot;We%20are%20happy.&quot;</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span>(Character c:s.toCharArray())&#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            sb.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            sb.append(c);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需注意<code>字符用&#39; &#39;号</code></p><h3 id="左旋字符串"><a href="#左旋字符串" class="headerlink" title="左旋字符串"></a>左旋字符串</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”</p><p>示例 1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abcdefg&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出:<span class="hljs-string">&quot;cdefgab&quot;</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;lrloseumgh&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">6</span><br>输出:<span class="hljs-string">&quot;umghlrlose&quot;</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>       StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&lt;s.length();i++)&#123;<br>           sb.append(s.charAt(i));<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>           sb.append(s.charAt(i));<br>       &#125;<br>       <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><code>LinkedList</code>的一些<a href="https://www.runoob.com/java/java-linkedlist.html">常用方法</a></p><h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>示例 1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,3,2]</span><br>输出：<span class="hljs-comment">[2,3,1]</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint(ListNode head) &#123;<br>      LinkedList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>      <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span>)&#123;<br>          list.addLast(head.val);<br>          head=head.next;<br>      &#125;<br>      <span class="hljs-type">int</span>[] result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()];<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;result.length;i++)&#123;<br>            result[i]=list.removeLast();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点</p><p>示例:</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL<br>输出: <span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>       ListNode prev=<span class="hljs-literal">null</span>;<br>       ListNode curr=head;<br>       <span class="hljs-keyword">while</span>(curr!=<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(curr.val);<br>            node.next=prev;<br>            prev=node;<br>            curr=curr.next;<br>       &#125;<br>       <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点</p><p>示例 1:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: head = [4,5,1,9], val = 5</span><br><span class="hljs-section">输出: [4,1,9]</span><br><span class="hljs-section">解释: 给定你链表中值为5的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head.val==val)&#123;<br>            <span class="hljs-keyword">return</span> head.next;<br>        &#125;<br>        ListNode pre=head;<br>        ListNode cur=head.next;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">if</span>(cur.val==val)&#123;        <br>                pre.next=cur.next;<br>                <span class="hljs-keyword">return</span> head;<br>        &#125;<br>         cur=cur.next;<br>         pre=pre.next;<br>        &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">给定一个链表: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 和 k = <span class="hljs-number">2.</span><br><br>返回链表 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5.</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>       ListNode curr=head;<br>       ListNode prev=head;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>           curr=curr.next;<br>       &#125;<br>       <span class="hljs-keyword">while</span>(curr!=<span class="hljs-literal">null</span>)&#123;<br>           curr=curr.next;<br>           prev=prev.next;<br>       &#125;<br>       <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的</p><p>示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span><br>输出：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 递归代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(l1==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l1.val&lt;l2.val)&#123;<br>            l1.next=mergeTwoLists(l1.next,l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l2.next=mergeTwoLists(l1,l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//非递归代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>      <span class="hljs-keyword">if</span>(l1==<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-keyword">return</span> l2;<br>      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2==<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-keyword">return</span> l1;<br>      &#125;<br>      ListNode pre=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>      ListNode p=pre;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">null</span>&amp;&amp;l2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1.val&gt;l2.val)&#123;<br>               p.next=l2;<br>               l2=l2.next;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                p.next=l1;<br>               l1=l1.next;<br>            &#125;<br>            p=p.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l1!=<span class="hljs-literal">null</span>)&#123;<br>            p.next=l1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2!=<span class="hljs-literal">null</span>)<br>        &#123;<br>            p.next=l2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h3><p>输入两个链表，找出它们的第一个公共节点</p><p>示例：<br><img src="/image/LeetCode/%E5%85%AC%E5%85%B1%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9.png"></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：<span class="hljs-keyword">Reference</span> of the <span class="hljs-keyword">node</span> <span class="hljs-title">with</span> value = <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>            pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;<br>            pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分</p><p>示例：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>]<br>输出：[<span class="hljs-number">1,3,2,4</span>] <br>注：[<span class="hljs-number">3,1,2,4</span>] 也是正确的答案之一<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] exchange(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span>[] res= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>            <span class="hljs-keyword">if</span>(num%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                res[right]=num;<br>                right--;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res[left]=num;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h3><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可</p><p>示例 1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[2,7]</span> 或者 <span class="hljs-comment">[7,2]</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-keyword">if</span>(nums==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=nums.length;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> s=nums[l]+nums[r];<br>            <span class="hljs-keyword">if</span>(s&lt;target) i++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s&gt;target) j--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;nums[i],nums[j]&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I</p><p>示例1：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;the sky is blue&quot;</span><br>输出: <span class="hljs-string">&quot;blue is sky the&quot;</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>      s=s.trim();<br>      <span class="hljs-type">int</span> left=s.length()-<span class="hljs-number">1</span>,right=left;<br>      StringBuilder res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>      <span class="hljs-keyword">while</span>(left&gt;=<span class="hljs-number">0</span>)&#123;<br>          <span class="hljs-keyword">while</span>(left&gt;=<span class="hljs-number">0</span>&amp;&amp;s.charAt(left)!=<span class="hljs-string">&#x27; &#x27;</span>) left--;<br>          res.append(s.substring(left+<span class="hljs-number">1</span>,right+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot; &quot;</span>);<br>          <span class="hljs-keyword">while</span>(left&gt;=<span class="hljs-number">0</span>&amp;&amp;s.charAt(left)==<span class="hljs-string">&#x27; &#x27;</span>) left--;<br>          right=left;<br>      &#125;<br>      <span class="hljs-keyword">return</span> res.toString().trim();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>示例 1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[<span class="hljs-number">3</span>],[],[],[]]<br>输出：[null,null,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span>&#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack1;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack2;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>     stack1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>     stack2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>    &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>      stack2.push(value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">if</span>(stack1.isEmpty())&#123;<br>         <span class="hljs-keyword">while</span>(!stack2.isEmpty())&#123;<br>           stack1.push(stack2.pop()); <br>         &#125;   <br>     &#125;<br>     <span class="hljs-keyword">return</span> stack1.isEmpty()?-<span class="hljs-number">1</span>:stack1.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)</p><p>示例:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">MinStack minStack <span class="hljs-operator">=</span> new MinStack()<span class="hljs-comment">;</span><br>minStack.push(-<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br>minStack.push(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>minStack.push(-<span class="hljs-number">3</span>)<span class="hljs-comment">;</span><br>minStack.min()<span class="hljs-comment">;   --&gt; 返回 -3.</span><br>minStack.pop()<span class="hljs-comment">;</span><br>minStack.top()<span class="hljs-comment">;      --&gt; 返回 0.</span><br>minStack.min()<span class="hljs-comment">;   --&gt; 返回 -2.</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    Stack&lt;Integer&gt; A,B;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        A=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        B=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        A.add(x);<br>        <span class="hljs-keyword">if</span>(B.empty() || B.peek()&gt;=x)&#123;<br>            B.add(x);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(A.pop().equals(B.peek()))&#123;<br>            B.pop();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> A.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> B.peek();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字</p><p>示例 1：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<br><span class="hljs-string">[2, 3, 1, 0, 2, 5, 3]</span><br>输出：<span class="hljs-number">2</span> 或 <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span>[] res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res[nums[i]]++;<br>        &#125;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(res[j]&gt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2023/07/27/Redis/"/>
    <url>/2023/07/27/Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h2><p>1、<strong>String（字符串）：</strong>最基本的数据类型，可以包含任何形式的数据，如文本、整数或二进制数据。Redis支持对字符串进行简单的操作，例如获取、设置、追加等。</p><p>使用场景：</p><ul><li>缓存数据：常用于缓存数据库查询结果、计算结果等。</li><li>计数器：可以实现简单的计数功能，如用户点击次数统计、消息计数等。</li><li>分布式锁：使用字符串的SETNX命令可以实现简单的分布式锁</li></ul><p>2、<strong>List（列表）：</strong>由多个按插入顺序排列的元素组成，可以在列表的头部或尾部添加或删除元素。列表支持范围查找、修剪和阻塞式弹出等操作，非常适合实现队列、栈等数据结构。</p><p>使用场景：</p><ul><li>消息队列：作为简单的消息队列，支持队列的压入和弹出操作，适用于异步任务处理等场景。</li><li>历史记录：可用于存储最近的操作历史，如用户最近的登录记录、操作记录等</li></ul><p>3、<strong>Set（集合）：</strong>不重复的、无序的元素集合。集合支持集合运算，如交集、并集、差集等，还可以随机获取元素。</p><p>使用场景：</p><ul><li>标签、兴趣爱好等：存储不重复的标签或用户兴趣爱好等信息。</li><li>好友关系：用于存储用户的好友关系，并支持快速的交集、并集等操作</li></ul><p>4、<strong>Sorted Set（有序集合）：</strong>类似于集合，但每个元素都关联一个分数（score），根据分数排序。可以根据分数范围获取元素，还支持按分数顺序获取元素，常用于排行榜、范围查询等场景。</p><p>使用场景：</p><ul><li>排行榜：存储用户的排行榜数据，按分数排序，支持快速查找前几名、范围查询等。</li><li>带有权重的任务队列：任务按照优先级排序，根据分数选择优先处理</li></ul><p>5、<strong>Hash（哈希）：</strong>存储字段和值的映射，类似于关联数组或字典。哈希可以对单个字段进行操作，也可以获取所有字段的值。</p><p>使用场景：</p><ul><li>用户信息：适合存储用户对象的属性，如姓名、年龄、地址等。</li><li>缓存对象：用于存储复杂对象，以便快速获取和更新对象的属性</li></ul><p>6、<strong>Bitmap：</strong>一个由字符串组成的位图，可以对位图进行位操作，例如计数、并集、交集等。</p><p>使用场景：</p><ul><li>用户在线状态：每一位表示一个用户是否在线，用于快速判断用户在线状态。</li><li>用户签到：每一位表示用户是否在某天签到，用于实现签到功能</li></ul><p>7、<strong>HyperLogLog：</strong>用于进行基数（cardinality）估计的数据结构，可以统计集合中元素的数量，占用很小的空间。</p><p>使用场景：</p><ul><li>基数估计：用于估计数据集的基数，如统计网站的独立访客数、活跃用户数等</li></ul><p>8、<strong>GeoSpatial（地理位置）：</strong>存储地理位置的数据结构，可以进行空间查询，查找附近的地理位置</p><p>使用场景：</p><ul><li>附近的人或地点：根据地理位置进行附近的人或地点的查询</li></ul><h2 id="缓存穿透、缓存击穿、缓存雪崩及其解决方案"><a href="#缓存穿透、缓存击穿、缓存雪崩及其解决方案" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩及其解决方案"></a>缓存穿透、缓存击穿、缓存雪崩及其解决方案</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指在缓存系统中，大量的请求查询一个不存在的数据，导致这些请求都无法从缓存中获取到结果，最终都要穿透到后端数据库或其他数据源进行查询，这样会增加数据库的负载和延迟</p><p><strong>解决缓存穿透的方法：</strong><br>1、<strong>布隆过滤器：</strong>使用布隆过滤器可以在缓存层面快速判断一个请求的查询值是否可能存在于数据库中。如果布隆过滤器判断请求的查询值一定不存在，可以直接拒绝该请求，避免对数据库的查询操作。这样可以有效降低缓存穿透的风险</p><p>布隆过滤器的工作原理：<br>布隆过滤器的位数组初始化时所有的位都被置为0。当一个元素要被添加到布隆过滤器中时，会将该元素经过多个哈希函数计算得到多个哈希值，并将对应的位数组上的位置置为1。当要查询一个元素是否存在于布隆过滤器时，同样将该元素经过多个哈希函数计算得到多个哈希值，然后检查对应的位数组上的位置是否都为1，如果有任何一个位置为0，则可以确定该元素一定不存在于集合中；如果所有位置都为1，则说明该元素可能存在于集合中</p><p><strong>但是值得注意的是：布隆过滤器会误判</strong><br>这是因为多个元素经过哈希函数计算得到的哈希值可能会冲突，导致它们对应的位数组上的位置都被置为1，从而造成误判</p><p>2、<strong>缓存空对象：</strong>对于查询的值不存在的情况，可以在缓存中存储一个特殊的空对象作为响应结果。这样，当有查询请求到来时，即使数据库中没有对应的数据，也可以返回缓存中的空对象，避免直接穿透到数据库。需要注意的是，缓存空对象的过期时间要适当设置，避免长时间存储无效的数据</p><p>3、<strong>数据预热：</strong>在系统启动或低峰期，提前将常用的数据加载到缓存中，预热缓存。这样可以避免系统刚启动或高峰期时，大量请求直接穿透到数据库。通过预热缓存，可以提高缓存命中率，减少缓存穿透的概率</p><p>4、<strong>异常请求过滤：</strong>在应用程序的入口处，对请求进行过滤和验证。可以通过对请求参数进行合法性校验、黑名单过滤等方式，拦截掉异常请求，减少无效请求对缓存和数据库的影响</p><p>5、<strong>热点数据缓存：</strong>针对一些频繁被查询的热点数据，可以将其主动缓存在缓存中，并设置适当的过期策略。这样可以在高并发情况下，减少对数据库的直接查询，提高系统的性能和响应速度</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指一个非常热门的缓存键（key）在缓存中过期或者被删除，同时又有大量的并发请求同时访问这个缓存键所对应的数据，导致请求直接落到后端数据库或其他数据源上，引起数据库负载骤增，甚至导致数据库崩溃的情况</p><p><strong>解决缓存击穿的方法：</strong><br>1、<strong>设置热点数据永不过期：</strong>对于非常热门的缓存数据，可以将其设置为永不过期，确保即使在缓存失效的情况下，仍然可以从缓存中获取到数据。这样可以避免因为缓存键过期而引起的大量请求落到数据库上</p><p>2、<strong>使用互斥锁：</strong>当一个请求发现缓存中的数据已经过期时，可以使用互斥锁来保证只有一个请求去加载数据到缓存中，其他请求等待该请求完成后再从缓存中获取数据。这样可以避免多个请求同时去查询数据库，减轻数据库的负载</p><p>3、<strong>数据预热：</strong>在系统启动或者低峰期，提前加载热点数据到缓存中，进行数据预热。这样可以避免系统刚启动或者热点数据失效时的缓存击穿问题</p><p>4、<strong>限流策略：</strong>通过设置合理的限流策略，控制并发访问热点数据的请求数量。可以使用信号量、令牌桶等限流算法来限制请求的流量，避免过多的请求同时访问热点数据</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在缓存系统中，大量的缓存同时失效或过期，导致大量的请求直接落到后端数据库或其他数据源上，引起数据库负载骤增，甚至导致数据库崩溃的情况</p><p><strong>解决缓存雪崩的方法：</strong><br>1、<strong>设置合理的过期时间：</strong>在设计缓存时，合理设置缓存数据的过期时间，并考虑数据的访问模式和更新频率。可以通过设置随机的过期时间，避免大量缓存同时过期导致的雪崩效应</p><p>2、<strong>引入缓存失效时间的随机性：</strong>在缓存失效时间上引入一定的随机性，避免缓存同时失效。可以通过在缓存的过期时间上增加一个随机值，使得缓存的失效时间分散开，减少雪崩效应</p><p>3、<strong>缓存预加载和平滑更新：</strong>在缓存过期之前，提前异步地从数据库中加载数据到缓存中，避免大量请求落到数据库上。同时，在缓存过期后，异步更新缓存数据，而不是一次性更新所有失效的缓存。这样可以平滑地分散数据库负载，避免雪崩效应的发生</p><p>4、<strong>熔断机制和限流策略：</strong>在缓存系统和数据库之间引入熔断机制和限流策略，可以控制请求的流量，避免突发的大量请求冲击数据库。通过合理的限流策略，可以稳定系统的负载，减少雪崩效应的发生</p><h2 id="Redis怎样解决与数据库数据一致性的问题"><a href="#Redis怎样解决与数据库数据一致性的问题" class="headerlink" title="Redis怎样解决与数据库数据一致性的问题"></a>Redis怎样解决与数据库数据一致性的问题</h2><p>1、<strong>缓存更新策略：</strong>在对数据库进行增删改操作时，及时更新对应的缓存数据。例如，当数据库中的数据发生变动时，通过在同一事务中更新数据库和缓存，确保二者的数据保持一致。</p><p>2、<strong>读写分离：</strong>将数据库的读操作和写操作进行分离，读操作优先从缓存中获取数据，写操作更新数据库并清除相应的缓存。这样可以提高系统的性能和并发能力，并保证数据的一致性。</p><p>3、<strong>更新缓存策略：</strong>在数据库数据更新后，可以通过立即更新缓存的方式来保持数据的一致性。比如，在更新数据库之后，直接删除或者更新缓存中相应的数据，下一次读取时会从数据库中获取最新的数据并更新到缓存中。</p><p>4、<strong>读写加锁：</strong>在进行读写操作时，可以使用分布式锁来保证数据的一致性。在读操作时获取共享锁，允许多个请求同时读取缓存数据；在写操作时获取独占锁，确保只有一个请求能够更新数据库和缓存。</p><p>5、<strong>过期策略和淘汰策略：</strong>可以根据数据的特性和业务需求，设置合适的缓存过期策略和淘汰策略。例如，设置缓存数据的过期时间，以及使用LRU（Least Recently Used）等算法来淘汰长时间未使用的数据，保持缓存的有效性和减少数据不一致的可能性</p><h2 id="Redis如何解决并发竞争的问题"><a href="#Redis如何解决并发竞争的问题" class="headerlink" title="Redis如何解决并发竞争的问题"></a>Redis如何解决并发竞争的问题</h2><p>1、<strong>使用事务：</strong>Redis提供了事务机制，可以将一系列的操作组合成一个原子性的操作。通过使用事务，可以确保在执行期间不会被其他客户端的操作中断，从而避免并发竞争的问题。使用MULTI、EXEC和WATCH等命令来实现事务操作。</p><p>2、<strong>使用分布式锁：</strong>在并发环境下，可以使用分布式锁来保证对Redis的操作是互斥的。可以利用Redis的SETNX命令或者RedLock算法等方式实现分布式锁，确保同一时刻只有一个客户端能够执行关键操作。</p><p>3、<strong>使用乐观锁和版本号控制：</strong>通过在数据中引入版本号或时间戳，可以在并发操作时检测到数据是否被其他客户端修改，从而避免并发冲突。在更新数据时，先比较版本号或时间戳，如果与预期不一致，则放弃更新操作或进行重试。</p><p>4、<strong>使用管道（Pipeline）：</strong>Redis的管道功能可以将多个命令一次性发送给服务器执行，并在一次通信中返回多个结果。通过使用管道，可以减少网络通信的开销，提高并发操作的性能。</p><p>5、<strong>配置连接池：</strong>适当配置Redis的连接池参数，如最大连接数、最大空闲连接数等，可以提高并发处理的能力。合理管理连接池可以避免资源竞争和性能瓶颈</p><h2 id="Redis的过期策略"><a href="#Redis的过期策略" class="headerlink" title="Redis的过期策略"></a>Redis的过期策略</h2><p>Redis过期策略是：<strong>定期删除+惰性删除</strong></p><p>定期删除：指的是Redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查是否过期，如果过期就删除</p><p>因为定期删除是随机抽取，所以这就可能导致很多过期key到了时间并没有被删除</p><p>惰性删除：获取key的时候，如果此时key已经过期，就删除，不会返回任何东西</p><p>但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 Redis 内存块耗尽了，咋整？</p><p>答案是：走<code>内存淘汰机制</code></p><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><ul><li><p><strong>oeviction（默认）:</strong> 当内存不足时，所有写入操作都会返回错误。这将强制客户端需要处理内存不足的情况。</p></li><li><p>**allkeys-lru（Least Recently Used）:**在所有的键中，LRU算法将选择最近最少使用的键进行淘汰。</p></li><li><p><strong>allkeys-random（Random）:</strong> 在所有的键中，随机选择一些键进行淘汰。</p></li><li><p><strong>volatile-lru:</strong> 只对设置了过期时间（TTL）的键中选择最近最少使用的键进行淘汰。</p></li><li><p><strong>volatile-random:</strong> 只对设置了过期时间的键中随机选择一些键进行淘汰。</p></li><li><p><strong>volatile-ttl:</strong> 只对设置了过期时间的键中，根据键的过期时间从小到大进行淘汰，即优先淘汰将要过期的键</p></li></ul><p>可以通过配置Redis的maxmemory-policy参数来指定所使用的淘汰策略。例如，如果要将Redis的最大内存限制设置为100MB，并且希望使用LRU算法进行内存淘汰，可以在配置文件中设置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">maxmemory 100mb<br>maxmemory-policy allkeys-lru<br></code></pre></td></tr></table></figure><p>一个简单的LRU算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> HashMap&lt;Integer, Integer&gt; cache;<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; ordering;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        ordering = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cache.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 将访问过的数据移动到链表头部表示最近使用</span><br>            ordering.remove((Integer) key);<br>            ordering.addFirst(key);<br>            <span class="hljs-keyword">return</span> cache.get(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cache.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 如果键已存在，则更新值并移动到链表头部</span><br>            cache.put(key, value);<br>            ordering.remove((Integer) key);<br>            ordering.addFirst(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (ordering.size() &gt;= capacity) &#123;<br>                <span class="hljs-comment">// 如果容量已满，则移除最久未使用的数据</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">removedKey</span> <span class="hljs-operator">=</span> ordering.removeLast();<br>                cache.remove(removedKey);<br>            &#125;<br>            <span class="hljs-comment">// 插入新数据到链表头部</span><br>            cache.put(key, value);<br>            ordering.addFirst(key);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个实现中，我们使用了一个<code>HashMap</code>来保存键值对，同时使用一个<code>LinkedList</code>来记录数据的访问顺序，链表头部表示最近使用的数据，链表尾部表示最久未被使用的数据。</p><p><code>get()</code> 方法用于获取缓存中的数据，如果键存在，则返回对应的值，并将访问过的数据移动到链表头部。</p><p><code>put()</code>方法用于插入新的键值对。如果键已经存在，则更新值并将对应的键移动到链表头部。如果缓存容量已满，则移除链表尾部的数据，并在哈希表中删除对应的键值对</p><h2 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h2><p><strong>RDB（Redis Database）持久化：</strong></p><p>RDB持久化是通过快照的方式来实现的，将数据在指定时间点上的状态以二进制文件的形式保存到磁盘上。<br>可以手动执行SAVE或者BGSAVE命令来触发RDB持久化。SAVE会阻塞Redis服务器，直到持久化完成，而BGSAVE会在后台执行持久化操作，不会阻塞其他操作。<br>RDB持久化适用于数据集较大、数据更新不频繁的情况，可以在备份和数据恢复时提供较好的性能。</p><p><strong>AOF（Append-Only File）持久化：</strong></p><p>AOF持久化通过将每个写操作追加到一个日志文件中，记录了所有对Redis数据的修改操作。当Redis重启时，可以通过重新执行AOF日志中的命令来恢复数据。<br>AOF持久化可以通过appendfsync配置项设置为always、everysec或no三种模式，控制写入AOF文件的同步频率。<br>AOF持久化适用于对数据安全性要求较高、数据更新频繁的情况，但相比RDB持久化，AOF文件通常会更大</p><h2 id="Redis的高可用"><a href="#Redis的高可用" class="headerlink" title="Redis的高可用"></a>Redis的高可用</h2><p>Redis 的高可用架构，叫做 failover 故障转移，也可以叫做主备切换</p><p>1、<strong>主从复制（Master-Slave Replication）:</strong><br>主从复制是最简单的高可用方案之一。在主从复制中，一个Redis节点充当主节点（Master），其他节点充当从节点（Slave）。主节点负责处理写操作和读操作，而从节点只负责复制主节点的数据，对于客户端的读请求可以在从节点上进行，从而减轻主节点的负载</p><p>主从复制的优点是实现简单，只需要配置主节点和从节点的关系即可。如果主节点出现故障，可以手动将从节点升级为主节点，从而实现故障转移</p><p>2、<strong>哨兵（Sentinel）：</strong><br>哨兵是Redis官方提供的用于监控和自动故障转移的解决方案。哨兵是一个独立的进程，可以监控多个Redis节点的健康状态，并在主节点宕机时自动将一个从节点升级为新的主节点，实现自动故障转移</p><p>哨兵集群通常由多个哨兵节点组成，它们之间通过选举机制来决定谁负责监控和执行故障转移。哨兵节点之间会进行信息交换，通过多数节点达成共识来进行决策</p><h2 id="Redis集群模式"><a href="#Redis集群模式" class="headerlink" title="Redis集群模式"></a>Redis集群模式</h2><h3 id="分布式寻址算法"><a href="#分布式寻址算法" class="headerlink" title="分布式寻址算法"></a>分布式寻址算法</h3><p>1、<strong>hash算法：</strong><br>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致大部分的请求过来，全部无法拿到有效的缓存，导致大量的流量涌入数据库</p><p><img src="/image/Redis/hash.png"></p><p>2、<strong>一致性hash算法：</strong><br>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置</p><p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，遇到的第一个 master 节点就是 key 所在位置。</p><p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理</p><p>然而，一致性hash算法在节点太少并且节点分布不均匀时会导致缓存热点的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡</p><p><img src="/image/Redis/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95.png"></p><p>3、<strong>hash slot算法：</strong><br>Redis cluster 有固定的 16384 个 hash slot，对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的 hash slot</p><p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 hash tag 来实现</p><p>任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器</p><p><img src="/image/Redis/slot.png"></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb</title>
    <link href="/2023/07/27/JavaWeb/"/>
    <url>/2023/07/27/JavaWeb/</url>
    
    <content type="html"><![CDATA[<h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><p>1、<strong>初始化：</strong></p><ul><li>当Servlet容器启动或在第一次接收到与Servlet相关的请求时，会创建一个Servlet实例</li><li>在Servlet实例被创建后，Servlet容器会调用<code>init(ServletConfig config)</code>方法来初始化Servlet</li><li><code>init()</code>方法只会被调用一次，在Servlet的整个生命周期内都只有一个实例对象</li></ul><p>2、<strong>服务处理：</strong></p><ul><li>在Servlet初始化之后，Servlet容器会根据接收到的每个客户端请求，调用Servlet的<code>service(ServletRequest request, ServletResponse response)</code>方法来处理请求</li><li><code>service()</code>方法负责处理请求并生成响应，它会根据请求的类型（如GET、POST等）来调用相应的处理方法，比如<code>doGet()</code>、<code>doPost()</code>等</li><li><code>service()</code>方法可以被多次调用，每次请求都会调用<code>service()</code>方法来处理</li></ul><p>3、<strong>销毁：</strong></p><ul><li>当Servlet容器关闭或者从Web应用程序中移除Servlet时，会调用Servlet的<code>destroy()</code>方法</li><li><code>destroy()</code>方法在Servlet实例被销毁前被调用，可以用于释放资源、保存状态等清理工作</li><li><code>destroy()</code>方法只会被调用一次，在Servlet对象被销毁时触发</li></ul><h2 id="Session和Cokkie的区别"><a href="#Session和Cokkie的区别" class="headerlink" title="Session和Cokkie的区别"></a>Session和Cokkie的区别</h2><p>1、<strong>存储位置：</strong></p><ul><li><code>Cokkie</code>：是由服务器发送给浏览器，并存储在客户端（浏览器）中的小型文本文件。每次客户端向服务器发送请求时，<code>Cokkie</code>会随着请求一起发送到服务器</li><li><code>Session</code>：是服务器端的一种机制，它在服务器上存储了一些用户数据。服务器通过在客户端存储一个<code>Session ID</code>(通常存储在<code>Cokkie</code>中)来跟踪与特定用户相关联的会话信息。实际的用户数据存储在服务器上，而非客户端</li></ul><p>2、<strong>存储内容：</strong></p><ul><li><code>Cokkie</code>：存储的是少量的文本数据，通常用于标识用户或记录一些简单的状态信息，例如登录凭证、用户偏好设置等</li><li><code>Session</code>：存储的数据没有明确的大小限制，可以存储较为复杂的对象或数据结构、因为数据存储在服务器上，所以理论上可以存储更多的信息</li></ul><p>3、<strong>安全性：</strong></p><ul><li><code>Cookie</code>：由于存储在客户端，<code>Cookie</code>可能会受到一定程度的安全风险，特别是如果包含敏感信息。可以通过设置<code>Cookie</code>的属性来提高安全性，如设置<code>HttpOnly</code>属性禁止客户端脚本访问<code>Cookie</code></li><li><code>Session</code>：相对于<code>Cookie</code>，<code>Session</code>更安全，因为实际的数据存储在服务器上，客户端只有一个<code>Session ID</code>，并不能直接访问会话数据。但是，<code>Session ID </code>存储在<code>Cookie</code>中的话，还是需要注意可能的安全风险，比如通过 XSS 攻击来获取<code>Session ID</code></li></ul><p>4、<strong>生命周期：</strong></p><ul><li><code>Cookie</code>：可以设置<code>Cookie</code>的过期时间，使其在一定时间后失效。可以设置长期有效的<code>Cookie</code>（比如保存登录凭证的Cookie），也可以设置会话级别的<code>Cookie</code>，在浏览器关闭后自动删除。</li><li><code>Session</code>：<code>Session</code>的生命周期通常与用户的访问会话相关联。当用户打开一个新的浏览器窗口或标签时，会生成一个新的<code>Session</code>；当用户关闭所有窗口或标签时，<code>Session</code>会过期销毁</li></ul><p>5、<strong>跨域支持：</strong></p><ul><li><code>Cookie</code>：<code>Cookie</code>允许在同一域名下的不同路径或子域之间共享。</li><li><code>Session</code>：<code>Session</code>不能直接在不同的域名之间共享，因为它是存储在服务器上的。如果需要在不同域之间共享数据，可以通过其他手段，如使用跨域资源共享（CORS）或其他服务器端的共享机制</li></ul><p><strong>当cokkie失效后会影响session吗</strong><br>当Cookie上的数据消失并不会直接影响Session上的数据。但是，由于Session通常依赖于Cookie中的标识符（<strong>Session ID</strong>）来进行关联，当Cookie上的Session ID消失时，服务器可能无法正确关联客户端的Session数据，从而可能导致会话的重新建立</p><h2 id="跨域请求的方式"><a href="#跨域请求的方式" class="headerlink" title="跨域请求的方式"></a>跨域请求的方式</h2><p>1、<strong>CORS（跨域资源共享）：</strong><br>CORS是一种由浏览器实现的机制，允许服务器在响应中设置一些头部信息，来告知浏览器是否允许跨域请求。具体来说，服务器可以在响应头中设置<code>Access-Control-Allow-Origin</code>头部来指定允许访问的域名，从而实现跨域请求</p><p>2、<strong>JOSNP：</strong><br>JSONP是一种通过动态创建<code>&lt;script&gt;</code>标签实现跨域请求的方法。JSONP不是真正的AJAX请求，而是通过在请求URL中添加一个回调函数名作为参数，然后服务器返回一个带有该回调函数的JSON数据，浏览器在收到数据时直接执行该回调函数。JSONP只支持GET请求，并且需要服务器支持JSONP请求</p><p>3、<strong>代理服务器：</strong><br>在一些情况下，可以使用代理服务器来转发请求，使请求从客户端发送到同一个域名下的服务器，然后由服务器再发送请求到目标域，最后再将结果返回给客户端。通过代理服务器转发请求，实现了在客户端不直接发起跨域请求的目的</p><p>4、<strong>WebSocket：</strong><br>WebSocket是一种双向通信协议，它在浏览器与服务器之间建立持久性的连接，可以绕过浏览器的同源策略。因为WebSocket是在建立连接时进行握手，而不是普通的跨域请求，所以可以实现跨域通信</p><h2 id="重定向和转发的区别"><a href="#重定向和转发的区别" class="headerlink" title="重定向和转发的区别"></a>重定向和转发的区别</h2><p>1、<strong>执行地点：</strong></p><ul><li>重定向：重定向是在客户端（浏览器）完成的，服务器会发送一个特殊的响应给客户端，告诉它应该请求另一个URL。然后，客户端会根据响应中的重定向信息重新发送一个新的请求，前往新的URL</li><li>转发：转发是在服务器端完成的，服务器会在接收到请求后，直接将请求转发给另一个目标资源（Servlet或JSP），目标资源再处理该请求，并将响应返回给客户端，客户端对此一无所知</li></ul><p>2、<strong>请求次数：</strong></p><ul><li>重定向：重定向需要两次请求，第一次是原始请求，服务器返回重定向响应后，客户端再发送第二次请求到新的URL</li><li>转发：转发只需要一次请求，客户端发送请求到服务器，服务器将请求转发给目标资源，并将目标资源的响应返回给客户端</li></ul><p>3、<strong>URL变化：</strong></p><ul><li>重定向：重定向会导致浏览器的URL地址发生改变，客户端会显示新的URL</li><li>转发：转发不会改变浏览器的URL地址，客户端看到的URL保持不变</li></ul><p>4、<strong>数据共享：</strong></p><ul><li>重定向：由于是两次请求，因此数据无法直接在重定向之间共享，除非使用URL参数或Cookie等手段</li><li>转发：由于在服务器端进行转发，目标资源可以直接访问原始请求的数据，并且可以在转发过程中共享数据，因此数据共享更方便</li></ul><p><strong>重定向示例代码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/redirect&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedirectServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// 完成重定向</span><br>        response.sendRedirect(<span class="hljs-string">&quot;https://www.example.com/newpage&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>转发示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/forward&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// 获取请求的Dispatcher对象，进行转发</span><br>        <span class="hljs-type">RequestDispatcher</span> <span class="hljs-variable">dispatcher</span> <span class="hljs-operator">=</span> request.getRequestDispatcher(<span class="hljs-string">&quot;/newpage.jsp&quot;</span>);<br>        dispatcher.forward(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JSP的九大内置对象"><a href="#JSP的九大内置对象" class="headerlink" title="JSP的九大内置对象"></a>JSP的九大内置对象</h2><p>1、<strong>request（请求对象）：</strong>表示客户端的HTTP请求，包含客户端传递的参数、请求头信息等**</p><p>2、<strong>response（响应对象）：</strong>表示服务器对客户端的HTTP响应，用于向客户端发送数据和响应信息</p><p>3、<strong>out（输出对象）：</strong> 用于向客户端输出内容，相当于response.getWriter()，用于输出HTML代码</p><p>4、<strong>session（会话对象）：</strong> 表示用户会话信息，用于在多个请求之间共享数据，通过session可以在同一个用户的不同请求之间保持数据状态</p><p>5、<strong>application（应用程序对象）：</strong> 表示整个Web应用的上下文，用于在整个应用中共享数据</p><p>6、<strong>pageContext（页面上下文对象）：</strong> 表示JSP页面的上下文，包含了对其他内置对象的引用</p><p>7、c<strong>onfig（配置对象）：</strong> 表示当前JSP页面的配置信息，可以获取部署描述符（web.xml）中的配置参数</p><p>8、<strong>page（页面对象）：</strong> 表示当前JSP页面本身，可以用于调用页面自身的方法</p><p>9、<strong>exception（异常对象）：</strong> 表示当前页面发生的异常信息（通常用于错误处理）</p>]]></content>
    
    
    
    <tags>
      
      <tag>javaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发编程同步器</title>
    <link href="/2023/07/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
    <url>/2023/07/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="JDK提供的用于并发编程的同步器"><a href="#JDK提供的用于并发编程的同步器" class="headerlink" title="JDK提供的用于并发编程的同步器"></a>JDK提供的用于并发编程的同步器</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized关键字用于实现对共享资源的互斥访问。通过在方法或代码块前添加synchronized关键字，可以保证同一时刻只有一个线程可以访问被保护的代码</p><p><code>线程安全</code>：synchronized关键字的主要目的是确保多个线程在访问共享资源时能够互斥地进行，防止出现数据不一致或异常的情况。当一个线程进入synchronized方法或代码块时，它会获得一个监视器锁（也称为内部锁或互斥锁），其他线程在没有获得该锁的情况下无法进入synchronized方法或代码块。</p><p><code>对象级别的锁</code>：当synchronized修饰实例方法时，锁定的是当前实例对象，不同实例对象之间的锁是相互独立的。也就是说，当不同线程在不同实例对象上调用synchronized方法时，它们不会相互阻塞。</p><p><code>类级别的锁</code>：当synchronized修饰静态方法时，锁定的是整个类的Class对象，该类的所有实例对象共享同一个锁。这意味着，当不同线程在不同实例对象上调用同一个静态synchronized方法时，它们会相互阻塞，因为它们尝试获取的是同一个类级别的锁。</p><p><code>锁粒度</code>：synchronized的锁粒度较粗，当一个线程获得了synchronized锁后，其他所有线程都无法进入同步方法或代码块，即使它们要访问的是不同的非synchronized方法。</p><p><code>阻塞与性能</code>：synchronized是重量级锁，在多线程竞争激烈的情况下，可能会导致线程的阻塞和上下文切换，从而降低性能。因此，在设计时，应尽量缩小synchronized锁的范围，避免在不必要的地方使用synchronized。</p><p><code>synchronized代码块</code>：除了修饰方法外，synchronized还可以用于修饰代码块。synchronized代码块更加灵活，可以指定任意对象作为锁对象，从而实现更细粒度的同步控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 锁定代码块</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 执行一些需要同步的操作</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个SynchronizedExample类，其中包含了一个实例变量count。我们使用synchronized关键字修饰了increment()方法，从而确保多个线程对count的操作是同步的。同时，我们还演示了使用synchronized代码块来实现更细粒度的同步控制，通过锁定this对象来保护一段需要同步的代码</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是一个可重入的互斥锁，它比synchronized提供更灵活的锁定机制。它支持公平性和非公平性，并且提供了一些额外的功能，如条件变量和可中断的获取锁操作</p><p><code>可重入性</code>：ReentrantLock是可重入的，意味着同一个线程可以多次获取该锁而不会导致死锁。当一个线程持有锁时，可以再次调用lock()方法，继续获取锁，而不会被阻塞。</p><p><code>公平性</code>：ReentrantLock可以在构造函数中选择是否使用公平锁。公平锁会按照线程的到达顺序来分配锁，而非公平锁则会允许抢占，不保证线程的执行顺序。</p><p><code>锁中断</code>：ReentrantLock提供了对锁中断的支持。当一个线程等待锁的过程中，它可以响应中断信号，终止等待并做相应处理。</p><p><code>条件变量</code>：ReentrantLock提供了Condition接口的实现，可以通过Condition对象实现更灵活的线程通信和等待&#x2F;通知机制。</p><p><code>锁粒度</code>：ReentrantLock的粒度可以更加细腻，可以使用lock()和unlock()方法来手动控制锁的获取和释放，从而实现更灵活的同步控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(); <span class="hljs-comment">// 创建ReentrantLock对象</span><br>    <span class="hljs-comment">//private final Lock lock = new ReentrantLock(true); // 使用公平锁</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        lock.lock(); <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            count++;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock(); <span class="hljs-comment">// 释放锁</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个ReentrantLock对象，并在increment()方法中使用lock()和unlock()方法来手动控制锁的获取和释放。这样做可以确保多线程对count的访问是安全的，并且允许同一个线程多次获取锁，从而实现可重入性。</p><p>ReentrantLock通常在需要更多灵活性和控制的情况下使用，特别是在需要使用条件变量或中断等功能时。在实现复杂的并发算法或线程间通信时，ReentrantLock比synchronized关键字更加强大和灵活。但需要注意，由于ReentrantLock的使用较复杂，编写时需要谨慎，避免死锁等问题</p><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><p>ReadWriteLock是一种读写锁，它允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这在读操作远远多于写操作的情况下可以提高并发性能</p><p><code>读锁（Read Lock）</code>：多个线程可以同时持有读锁，允许并发读取共享资源，读锁之间不会互斥。只有当没有线程持有写锁时，读锁才会被授予</p><p><code>写锁（Write Lock）</code>：只有一个线程可以持有写锁，写锁会互斥地排斥所有读锁和其他写锁。当有线程持有读锁时，写锁无法获取</p><p><code>锁降级</code>：ReadWriteLock支持锁降级，即将写锁降级为读锁。在持有写锁的情况下，可以获取读锁，然后释放写锁，这样就可以在不释放读锁的情况下继续读取共享资源</p><p><code>锁升级</code>：ReadWriteLock不支持锁升级，即不允许将读锁升级为写锁。如果一个线程持有读锁，想要进行写操作，必须先释放读锁，然后获取写锁</p><p><code>非公平性</code>：默认情况下，ReadWriteLock是非公平的，即不保证读锁和写锁的获取顺序。可以通过构造ReadWriteLock对象时，将fair参数设置为true来使用公平策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReadWriteLock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadWriteLockExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        readWriteLock.readLock().lock(); <span class="hljs-comment">// 获取读锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readWriteLock.readLock().unlock(); <span class="hljs-comment">// 释放读锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        readWriteLock.writeLock().lock(); <span class="hljs-comment">// 获取写锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            count++;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readWriteLock.writeLock().unlock(); <span class="hljs-comment">// 释放写锁</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个ReadWriteLock对象，并在getCount()方法中使用读锁（readLock()）来读取共享资源，使用increment()方法中使用写锁（writeLock()）来进行写操作。这样做可以提高读取操作的并发性能，因为读锁之间不会互斥。写锁保证了写操作的互斥性，只允许一个线程进行写操作</p><p>ReadWriteLock通常用于读多写少的场景，特别是在共享资源被频繁读取的情况下，通过使用读写锁可以减少线程的阻塞和上下文切换，提高并发性能。然而，使用ReadWriteLock时需要注意避免死锁和饥饿等问题，尤其在涉及锁降级的场景</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore是一种计数信号量，它可以控制同时访问某个资源的线程数量。它允许多个线程同时访问资源，但是需要限制并发访问的线程数量</p><p><code>计数信号量</code>：Semaphore内部维护一个计数器，用来表示可用的许可证（permit）数量。每当一个线程获取了许可证时，计数器就会减少，当计数器为零时，后续请求许可证的线程将被阻塞。</p><p><code>获取和释放许可证</code>：线程可以通过acquire()方法获取许可证，如果当前计数器大于零，则线程将成功获取许可证，计数器减1；如果计数器为零，则线程将被阻塞，直到有其他线程释放许可证。线程可以通过release()方法释放许可证，使得计数器增加。</p><p><code>信号量的大小</code>：在创建Semaphore对象时，需要指定信号量的大小，即初始的许可证数量。可以通过构造函数指定该值，也可以使用无参构造函数创建默认大小为1的信号量，从而实现类似于互斥锁的功能。</p><p><code>公平性</code>：Semaphore默认是非公平的，但可以在构造函数中将fair参数设置为true来使用公平策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 信号量大小为2</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            semaphore.acquire(); <span class="hljs-comment">// 获取许可证</span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; is doing some work.&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟线程的工作</span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; has completed its task.&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            semaphore.release(); <span class="hljs-comment">// 释放许可证</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个Semaphore对象，指定信号量的大小为2。在doWork()方法中，线程首先尝试获取许可证（acquire()），如果有可用的许可证，则继续执行任务；否则，线程将被阻塞，直到有其他线程释放许可证。在任务完成后，线程会释放许可证（release()），使得其他线程可以继续获取许可证。</p><p>Semaphore的灵活性和功能使得它在一些并发场景中非常有用，特别是需要控制并发线程数量或限制资源访问的情况下。它可以与其他同步工具如锁、条件变量等组合使用，实现更复杂的并发控制逻辑<br>信号量的应用：Semaphore常用于限制资源的访问，比如控制并发线程的数量，控制连接池的大小，限流等场景</p><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch是一种同步工具，它可以让一个或多个线程等待其他线程完成操作后再继续执行。通过减少计数器的值，当计数器为零时，等待的线程可以被唤醒</p><p>创建CountDownLatch时，需要指定一个”计数器数量”（也称为”count”），表示有多少个线程需要等待<br>当线程完成它们的任务后，会调用CountDownLatch的countDown()方法，将计数器值减1<br>当计数器的值减少到零时，所有等待的线程会被唤醒，继续执行后续操作</p><p>主要的方法：</p><ul><li>countDown()：将计数器的值减1，表示一个线程完成了它的任务</li><li>await()：让当前线程等待，直到计数器的值减少到零，或者等待超时</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; <span class="hljs-comment">// 计数器数量为3</span><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(count);<br><br>        <span class="hljs-comment">// 创建并启动三个线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; is doing some work.&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟线程的工作</span><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; has completed its task.&quot;</span>);<br>                    latch.countDown(); <span class="hljs-comment">// 完成任务后，将计数器减1</span><br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            thread.start();<br>        &#125;<br><br>        <span class="hljs-comment">// 等待所有线程完成任务</span><br>        latch.await();<br>        System.out.println(<span class="hljs-string">&quot;All threads have completed their tasks. The main thread continues.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//结果输出</span><br>Thread-<span class="hljs-number">0</span> is doing some work.<br>Thread-<span class="hljs-number">1</span> is doing some work.<br>Thread-<span class="hljs-number">2</span> is doing some work.<br>Thread-<span class="hljs-number">0</span> has completed its task.<br>Thread-<span class="hljs-number">1</span> has completed its task.<br>Thread-<span class="hljs-number">2</span> has completed its task.<br>All threads have completed their tasks. The main thread continues.<br><br></code></pre></td></tr></table></figure><p>在示例中，我们创建了一个CountDownLatch，指定计数器数量为3。然后，我们创建了3个线程，它们模拟执行一些任务，并在任务完成后调用了countDown()方法，将计数器值减1。在主线程中，我们使用await()方法等待所有线程完成任务。当计数器的值减少到零时，主线程被唤醒，继续执行后续操作。</p><p>CountDownLatch常用于一些场景，例如在主线程等待多个子线程全部完成后再继续执行，或者在多个子线程等待某个条件满足后同时开始执行</p><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier是另一种同步工具，它可以让一组线程互相等待，直到所有线程都达到某个公共屏障点，然后再继续执行</p><p>创建CyclicBarrier时，需要指定一个”参与者数量”（也称为”parties”），表示有多少个线程要在该屏障点上等待。<br>当线程到达屏障点时，它会调用CyclicBarrier的await()方法来等待其他线程。<br>当”参与者数量”的线程都调用了await()方法后，CyclicBarrier会自动打开栅栏，所有等待的线程会被唤醒并继续执行后续操作。<br>在栅栏打开后，如果需要重复使用CyclicBarrier，可以调用reset()方法重置栅栏，使得它重新进入等待状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CyclicBarrier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parties</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; <span class="hljs-comment">// 参与者数量为3</span><br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(parties, () -&gt; &#123;<br>            <span class="hljs-comment">// 当所有线程都到达屏障点后，会执行这个回调操作</span><br>            System.out.println(<span class="hljs-string">&quot;All threads have reached the barrier point!&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-comment">// 创建并启动三个线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; parties; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; is waiting at the barrier point.&quot;</span>);<br>                    barrier.await(); <span class="hljs-comment">// 等待其他线程</span><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; continues after the barrier.&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            thread.start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//结果输出</span><br>Thread-<span class="hljs-number">0</span> is waiting at the barrier point.<br>Thread-<span class="hljs-number">1</span> is waiting at the barrier point.<br>Thread-<span class="hljs-number">2</span> is waiting at the barrier point.<br>All threads have reached the barrier point!<br>Thread-<span class="hljs-number">0</span> continues after the barrier.<br>Thread-<span class="hljs-number">2</span> continues after the barrier.<br>Thread-<span class="hljs-number">1</span> continues after the barrier.<br><br></code></pre></td></tr></table></figure><p>在示例中，我们创建了一个CyclicBarrier，并指定参与者数量为3。然后，我们创建了3个线程，它们都会在屏障点上等待。当所有线程都调用了await()方法后，屏障点打开，所有线程都被唤醒并继续执行后续操作。注意输出顺序可能会因为线程的执行速度而有所不同，但是所有线程在打开栅栏后会继续执行</p><h3 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h3><p>Phaser是Java并发包中提供的高级同步工具，它比CyclicBarrier和CountDownLatch更加灵活。Phaser可以用于协调多个线程的执行，使得这些线程能够同步地达到一个共同的状态点。可以将Phaser看作是一个栅栏，它可以在多个阶段中同步多个线程</p><p>Phaser的主要特点和工作原理如下：</p><p><code>可以动态增减参与者数量</code>：与CyclicBarrier和CountDownLatch不同，Phaser可以动态地增加或减少参与者的数量，这使得Phaser在处理动态线程数量的场景中非常有用</p><p><code>阶段（Phase）</code>：Phaser可以将任务划分为多个阶段，每个阶段可以包含一个或多个线程。在每个阶段结束时，所有线程都将被等待，并且在所有线程都到达该阶段后，Phaser会自动进入下一个阶段</p><p><code>高度灵活的同步</code>：Phaser支持多个线程之间的同步，以及线程内部的同步，使得编写复杂的并发算法变得更加简单</p><p><code>高性能</code>：Phaser经过优化，具有较低的开销，可以在高并发场景下提供良好的性能。</p><p>Phaser的基本工作流程如下：</p><ul><li>创建Phaser时，需要指定初始的”参与者数量”</li><li>在每个阶段中，线程可以通过arrive()或arriveAndAwaitAdvance()方法通知Phaser到达了该阶段。arrive()方法将只通知Phaser当前线程已到达该阶段，而arriveAndAwaitAdvance()方法将等待所有线程都到达该阶段后再继续执行</li><li>在所有参与者都到达当前阶段后，Phaser会自动进入下一个阶段，等待下一阶段的到达</li></ul><p>以下是一个简单示例来帮助理解Phaser：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Phaser;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicPhaserExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Phaser</span> <span class="hljs-variable">phaser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phaser</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 初始参与者数量为1</span><br><br>        <span class="hljs-comment">// 创建并启动三个线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; is doing some work.&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟线程的工作</span><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; has completed its task.&quot;</span>);<br><br>                    <span class="hljs-comment">// 告知Phaser当前线程已经到达当前阶段，并等待其他线程</span><br>                    phaser.arriveAndAwaitAdvance();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            thread.start();<br>        &#125;<br><br>        <span class="hljs-comment">// 等待所有线程完成阶段一</span><br>        phaser.arriveAndAwaitAdvance();<br>        System.out.println(<span class="hljs-string">&quot;All threads have completed phase one.&quot;</span>);<br><br>        <span class="hljs-comment">// 在阶段二之前，动态增加三个新参与者</span><br>        phaser.register();<br>        phaser.register();<br>        phaser.register();<br><br>        <span class="hljs-comment">// 等待所有线程完成阶段二</span><br>        phaser.arriveAndAwaitAdvance();<br>        System.out.println(<span class="hljs-string">&quot;All threads have completed phase two.&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//运行结果：</span><br>Thread-<span class="hljs-number">0</span> is doing some work.<br>Thread-<span class="hljs-number">1</span> is doing some work.<br>Thread-<span class="hljs-number">2</span> is doing some work.<br>Thread-<span class="hljs-number">2</span> has completed its task.<br>Thread-<span class="hljs-number">0</span> has completed its task.<br>Thread-<span class="hljs-number">1</span> has completed its task.<br>All threads have completed phase one.<br>Thread-<span class="hljs-number">3</span> is doing some work.<br>Thread-<span class="hljs-number">4</span> is doing some work.<br>Thread-<span class="hljs-number">5</span> is doing some work.<br>Thread-<span class="hljs-number">4</span> has completed its task.<br>Thread-<span class="hljs-number">5</span> has completed its task.<br>Thread-<span class="hljs-number">3</span> has completed its task.<br>All threads have completed phase two.<br><br></code></pre></td></tr></table></figure><p><code>register()</code>：该方法用于将一个新的参与者注册到Phaser中。在任意时刻，我们可以通过调用register()方法来增加Phaser的参与者数量</p><p><code>bulkRegister(int parties)</code>：该方法可以一次性增加多个参与者数量，可以用于动态地扩展Phaser的参与者数量</p><p><code>arrive()</code>：该方法通知Phaser当前线程已经到达了当前阶段。当线程调用arrive()方法后，Phaser会将参与者数量增加1</p><p><code>arriveAndDeregister()</code>：该方法通知Phaser当前线程已经到达了当前阶段，并且从Phaser中注销当前线程。当线程调用arriveAndDeregister()方法后，Phaser会将参与者数量减少1，这样做可以动态地减少Phaser的参与者数量</p><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><p>LockSupport是一个用于线程阻塞和唤醒的工具类，它可以让线程在特定位置阻塞，并在其他线程发出信号时解除阻塞.LockSupport类提供了与每个线程关联的许可证（permit），线程可以通过消费许可证来阻塞自己或唤醒其他线程。LockSupport类的主要作用是替代传统的线程阻塞和唤醒方法，如wait()和notify()，以更加灵活和精确的方式控制线程的状态</p><p>LockSupport的特点和工作原理如下：</p><p><code>许可证（Permit）</code>：每个线程在LockSupport中都有一个与之关联的许可证（permit）。线程可以通过消费（使用）许可证来阻塞自己或唤醒其他线程</p><p><code>park()</code>：调用park()方法会使当前线程阻塞，直到获得一个许可证。如果当前线程已经拥有许可证，park()方法会立即返回，而不会阻塞。park()方法可以阻塞当前线程多次，但每个许可证只能用一次</p><p><code>unpark(Thread thread)</code>：调用unpark(Thread thread)方法会给指定线程分配一个许可证。如果目标线程因为调用park()而阻塞，调用unpark()方法后，目标线程会被唤醒</p><p><code>不需要同步块</code>：LockSupport的park()和unpark()方法不需要在同步块中调用，因为它们是静态方法，不涉及任何共享资源</p><p>LockSupport的使用场景主要包括：</p><ul><li>替代传统的wait()和notify()方法，用于线程之间的协调和通信</li><li>提供更细粒度的线程阻塞和唤醒控制，可以实现更加高效和灵活的线程交互模式</li></ul><p>以下是一个简单示例来帮助理解LockSupport:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; is going to be parked.&quot;</span>);<br>            LockSupport.park(); <span class="hljs-comment">// 阻塞当前线程</span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; has been unparked.&quot;</span>);<br>        &#125;);<br><br>        thread1.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 主线程睡眠2秒钟</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        LockSupport.unpark(thread1); <span class="hljs-comment">// 唤醒thread1线程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br>Thread-<span class="hljs-number">0</span> is going to be parked.<br>Thread-<span class="hljs-number">0</span> has been unparked.<br><br></code></pre></td></tr></table></figure><p>在示例中，我们创建了一个新线程thread1，并在该线程中调用park()方法阻塞该线程。在主线程中，我们睡眠了2秒钟后，调用unpark(thread1)方法来唤醒thread1线程。因为调用unpark()方法后，thread1线程已经获得了许可证，所以它会立即被唤醒，继续执行后续操作。</p><p>需要注意的是，park()和unpark()方法可以按任意顺序调用，因为LockSupport的许可证是与每个线程关联的，并且不需要在同步块中使用。这使得LockSupport更加灵活和方便</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引</title>
    <link href="/2023/07/23/MySQL%E7%B4%A2%E5%BC%95/"/>
    <url>/2023/07/23/MySQL%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><ul><li>索引是帮助MySQL高效获取数据的<strong>数据结构</strong>，目的是加快数据库的查询效率</li></ul><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p><strong>主键索引：</strong></p><ul><li>设定为主键后，数据库自动建立索引，InnoDB为聚簇索引，主键索引列值不能为空（Null）</li></ul><p><strong>唯一索引：</strong></p><ul><li>索引列的值必须唯一，但允许有空值（Null），但只允许有一个空值（Null）</li></ul><p><strong>复合索引：</strong></p><ul><li>一个索引可以包换多个列，多个列共同构成一个复合索引，但要注意选择合适的索引顺序，以便更好地支持常用的查询模式</li></ul><p><strong>全文索引：</strong></p><ul><li>全文索引引用于全文搜索，可以在文本字段中进行关键字搜索</li></ul><p><strong>空间索引：</strong></p><ul><li>空间索引是用于地理空间数据类型的索引，可以支持空间数据的快速搜索和计算</li></ul><h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p><strong>优点：</strong></p><ul><li>加快查询速度</li><li>降低数据表的扫描成本</li><li>唯一性约束</li><li>加快连接操作</li></ul><p><strong>缺点：</strong></p><ul><li>占用存储空间</li><li>降低插入、更新和删除的性能</li><li>不适合小表</li><li>索引失效问题</li><li>需要权衡选择</li></ul><h3 id="创建索引的基本操作"><a href="#创建索引的基本操作" class="headerlink" title="创建索引的基本操作"></a>创建索引的基本操作</h3><p><strong>创建主键索引：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">#建表时，主键默认为索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>(<br>    id <span class="hljs-type">varchar</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">primary</span> key,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>    age <span class="hljs-type">int</span><br>)<br><br>#查看<span class="hljs-keyword">user</span>表中的索引<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><p><strong>创建单列索引：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index name_index <span class="hljs-keyword">on</span> <span class="hljs-keyword">user</span>(name);<br></code></pre></td></tr></table></figure><p><strong>创建唯一索引：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index age_index <span class="hljs-keyword">on</span> <span class="hljs-keyword">user</span>(age);<br></code></pre></td></tr></table></figure><p><strong>创建复合索引：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index name_age_index <span class="hljs-keyword">on</span> <span class="hljs-keyword">user</span>(name,age);<br></code></pre></td></tr></table></figure><p><strong>满足复合索引的查询的原则：</strong><br><code>最左匹配原则</code><br>最左匹配原则的关键在于，在查询中，如果使用了该复合索引的第一个列 column1，那么索引将被用于加速查询。同样地，如果使用了前两个列 column1 和 column2，索引也可以被利用。但是，如果查询中只使用了第二个列 column2 或者第三个列 column3，而没有使用前面的列，那么复合索引将不会被用于优化查询</p><p>举个例子：</p><p>假设我们有一个复合索引 (age, city, salary)，包含了三个列 age、city 和 salary。那么以下查询将能够利用该索引：</p><ul><li>查询：SELECT * FROM employees WHERE age &#x3D; 30;</li><li>查询：SELECT * FROM employees WHERE age &#x3D; 30 AND city &#x3D; ‘New York’;</li><li>查询：SELECT * FROM employees WHERE age &#x3D; 30 AND city &#x3D; ‘New York’ AND salary &gt; 50000;<br>这些查询都是按照最左边的列开始匹配，因此复合索引可以被最大程度地利用</li></ul><p>然而，如果我们执行以下查询，复合索引将无法被利用：</p><ul><li>查询：SELECT * FROM employees WHERE city &#x3D; ‘New York’;</li><li>查询：SELECT * FROM employees WHERE city &#x3D; ‘New York’ AND salary &gt; 50000;<br>这是因为在这些查询中，并没有使用复合索引的最左边的列，索引无法被利用</li></ul><p>最左匹配原则强调了在设计复合索引时，需要根据常见的查询模式和业务需求来选择合适的索引顺序，以最大限度地提高查询性能。若索引的顺序不当，可能导致索引无法被充分利用，从而影响查询效率</p><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>MySQL索引是通过B+树（B+Tree）数据结构来实现的。B+树是一种平衡多路搜索树，它是对B树的一种优化和扩展，B+树在磁盘存储和查找效率方面具有优势</p><p>B+树的特点：</p><ul><li><strong>平衡性：</strong>B+树是一种平衡树，意味着从根节点到所有叶子节点的路径长度相等或相差不大。这使得在查找时能够快速定位到目标节点，减少查询时间</li><li><strong>多路搜索：</strong>B+树的每个节点可以存储多个关键字和指向子节点的指针。这使得每个节点可以存储更多的数据，减少树的高度，进而减少磁盘I&#x2F;O次数，提高查询效率</li><li><strong>顺序访问性：</strong>B+树的叶子节点形成了一个有序链表，便于范围查询和顺序遍历</li><li><strong>稳定性：</strong>B+树的插入和删除操作相对B树来说更加稳定，不容易产生频繁的节点分裂和合并，维持了树的平衡性</li></ul><p>在MySQL中，常见的索引类型包括：</p><ul><li><p><strong>B-Tree索引：</strong> 这是MySQL默认的索引类型，实际上是基于B+树来实现的，适用于所有的存储引擎。B-Tree索引适用于全值匹配查询和部分匹配查询</p></li><li><p><strong>哈希索引：</strong> 这种索引基于哈希表实现，适用于精确匹配查询，但不支持范围查询。哈希索引适用于存储引擎为Memory（内存表）或者使用NDB Cluster存储引擎的表</p></li><li><p><strong>全文索引：</strong> 这种索引用于全文搜索，适用于MyISAM和InnoDB存储引擎。它可以高效地进行全文本的匹配查询</p></li></ul><h3 id="B-Tree和B-Tree的区别"><a href="#B-Tree和B-Tree的区别" class="headerlink" title="B+Tree和B-Tree的区别"></a>B+Tree和B-Tree的区别</h3><p><strong>结构不同：</strong></p><ul><li>B-Tree：B-Tree是一种平衡多路搜索树，每个节点可以包含多个关键字和指向子节点的指针。B-Tree的非叶子节点和叶子节点存储的数据是一样的，数据记录分布在整个树中</li><li>B+Tree：B+Tree也是一种平衡多路搜索树，与B-Tree不同的是，B+树的非叶子节点只存储关键字，不存储实际的数据记录。所以的数据记录都存储在叶子节点中，叶子节点形成一个有序链表</li></ul><p><strong>数据分布不同</strong></p><ul><li>B-Tree：数据记录可以分布在整个树的节点中，非叶子节点也可以存储数据记录</li><li>B+Tree：所以的数据记录都只存储在叶子节点中，非叶子节点仅存储关键字，这样使得叶子节点形成了一个有序链表</li></ul><p><strong>遍历方式不同</strong></p><ul><li>B-Tree：由于数据记录可以存储在非叶子节点，所以在进行查找时可能需要通过多个节点来找到目标数据记录</li><li>B+Tree：所有的数据记录都存储在叶子节点中，因此在查找时只需要遍历叶子节点即可，减少了树的遍历次数</li></ul><p><code>归根到底它两的根本区别就是结构的不同</code><br><strong>B-Tree的数据结构：</strong><br><img src="/image/SQL/B-Tree.png"></p><p><strong>B+Tree的数据结构：</strong><br><img src="/image/SQL/B+Tree.png"></p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul><li>最佳左前缀法则：如果索引了多列，要遵循最左前缀法则，指的是查询从索引的最左前列开始并且不跳过索引中的列</li><li>不在索引列上做任何计算、函数操作，会导致索引失效而转向全表扫描</li><li>Mysql 在使用不等于时无法使用索引会导致全表扫描</li><li>is null 可以使用索引，但是 is not null 无法使用索引</li><li>like 以通配符开头会使索引失效导致全表扫描</li><li>字符串不加单引号索引会失效</li><li>使用 or 连接时索引失效。如果or前后存在非索引的列，索引失效</li></ul><h3 id="索引优化-1"><a href="#索引优化-1" class="headerlink" title="索引优化"></a>索引优化</h3><p>1、选择合适的索引：</p><ul><li>确保对频繁用于WHERE、JOIN和ORDER BY子句的列创建索引。这些列的索引将加速查询的执行</li><li>避免对那些很少使用或不会用于查询条件的列创建索引，因为不必要的索引会增加数据库维护的开销</li></ul><p>2、复合索引优化：</p><ul><li>如果查询中涉及多个列，考虑创建联合索引。联合索引能够覆盖多个列，从而减少索引的数量和查询的执行时间</li><li>确保联合索引中的列顺序符合查询中的列顺序，这样索引的效果才会最优化</li></ul><p>3、前缀索引：</p><ul><li>对于较长的字符串列，可以考虑使用前缀索引。前缀索引只索引列值的前几个字符，可以减少索引的大小和提高查询性能</li></ul><p>4、避免过多索引：</p><ul><li>虽然索引可以加速查询，但过多的索引可能会导致查询优化器在决定使用哪个索引时变得复杂。这可能导致性能下降</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java IO</title>
    <link href="/2023/07/21/Java%20IO/"/>
    <url>/2023/07/21/Java%20IO/</url>
    
    <content type="html"><![CDATA[<h2 id="常见的IO模型"><a href="#常见的IO模型" class="headerlink" title="常见的IO模型"></a>常见的IO模型</h2><ul><li>同步阻塞 I&#x2F;O</li><li>同步非阻塞 I&#x2F;O</li><li>多路复用I&#x2F;O</li><li>信号驱动 I&#x2F;O </li><li>异步 I&#x2F;O。</li></ul><h2 id="Java中常见的IO"><a href="#Java中常见的IO" class="headerlink" title="Java中常见的IO"></a>Java中常见的IO</h2><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I&#x2F;O)"></a>BIO (Blocking I&#x2F;O)</h3><p>BIO 属于同步阻塞 IO 模型 。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。<br><img src="/image/IO/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO.png"><br>BIO在连接数量不高时是没有问题的，但是如果连接数量太大，则会无能为力</p><h3 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking&#x2F;New I&#x2F;O)"></a>NIO (Non-blocking&#x2F;New I&#x2F;O)</h3><p>Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。NIO基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中或者从缓冲区写入到通道中。对于高负载、高并发的（网络）应用，应使用 NIO<br><img src="/image/IO/Java%E7%9A%84NIO%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png"><br>NIO和IO最大的区别就是，<strong>IO是面向流的、NIO是面向缓存区的</strong></p><p>从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送 数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从Buffer 中取出数据来处理<br><img src="/image/IO/NIO%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%9E%8B.png"></p><hr>NIO中的Channel我们称之为通道，它与Stream流比较类似，只不过Stream流是单向的只能读，而Channel是双向的，可读可写<hr><p><strong>我们重点来学习一下NIO中的Selector</strong></p><hr>Selector 能够检测多个注册的通道上是否有事件发生，如果有事 件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可 以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -> 用户空间）还是阻塞的<h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I&#x2F;O)"></a>AIO (Asynchronous I&#x2F;O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步IO模型。异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><strong>BIO、NIO、AIO之间的关系</strong><br><img src="/image/IO/BIO%E3%80%81NIO%E3%80%81AIO%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><ul><li>根据数据处理的不同类型分为：字节流和字符流</li><li>根据数据流向不同分为：输入流和输出流<br><strong>字节流和字符流的区别：</strong></li><li>读写单位不同：字节流以字节(8bit)为单位。字符流以字符为单位</li><li>处理对象不同：字节流可以处理任何类型的数据，如图片、AVI等，而字符流只能处理字符类型的数据<br><strong>输入流和输出流的区别：</strong></li><li>对于输入流只能进行读操作</li><li>对于输出流只能进行写操作</li></ul><h2 id="Java-IO流对象"><a href="#Java-IO流对象" class="headerlink" title="Java IO流对象"></a>Java IO流对象</h2><p><strong>输入字节流InputStream：</strong><br><code>InputStream</code>类是面向字节流的，适用于处理二进制数据或文本数据的字节表示</p><p>一些常用的<code>InputStream</code>的子类包括：<br>1、<code>FileInputStream</code>：用于从文件中读取数据<br>2、<code>ByteArrayInputStream</code>：将字节数组作为输入源，方便从内存中读取数据<br>3、<code>BufferedInputStream</code>：提供缓冲功能，加快读取速度<br>4、<code>DataInputStream</code>：用于以特定的格式读取基本数据类型数据<br>5、<code>ObjectInputStream</code>：用于从流中反序列化Java对象</p><p>以下是使用<code>InputStream</code>读取数据的基本步骤：<br>1、创建<code>InputStream</code>的子类实例，比如<code>FileInputStream</code>或<code>ByteArrayInputStream</code><br>2、使用<code>read()</code>方法读取单个字节数据或使用<code>read(byte[] buffer)</code>方法读取一组字节数据到缓冲区<br>3、处理读取到的数据，通常将其写入其他地方或进行将进一步处理<br>4、在读取完数据后，关闭输入流，释放资源，可以使用<code>clone()</code>方法实现</p><p>实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamExample</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// 创建一个FileInputStream对象</span><br>FileInputStream inputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;example.txt&quot;</span>)；<br><span class="hljs-comment">// 读取单个字节并输出</span><br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span>inputStream.read();<br><span class="hljs-keyword">while</span>(data!=-<span class="hljs-number">1</span>)&#123;<br>System.out.print((<span class="hljs-type">char</span>) data);<br>data=inputStream.read();<br>&#125;<br><span class="hljs-comment">// 关闭输入流</span><br>inputStream.clone();<br>&#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，一般我们是不会直接单独使用 <code>FileInputStream</code>,通常会配合<code>BufferedInputStream</code>来使用。像下面这段代码在我们的项目中就比较常见，我们通过 <code>readAllBytes()</code> 读取输入流所有字节并将其直接赋值给一个 String 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 新建一个 BufferedInputStream 对象</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>));<br><span class="hljs-comment">// 读取文件的内容并复制到 String 对象中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bufferedInputStream.readAllBytes());<br>System.out.println(result);<br></code></pre></td></tr></table></figure><p><strong>输出字节流OutputStream：</strong><br><code>OutputStream</code>类是面向字节流的，适用于处理二进制数据或文本数据的字节表示</p><p>一些常用的<code>OutputStream</code>的子类包括：<br>1、<code>FileOutputStream</code>：用于从文件中写入数据<br>2、<code>ByteArrayOutputStream</code>：将字节数组作为目标，方便在内存中写入数据<br>3、<code>BufferedOutputStream</code>：提供缓冲功能，加快写入速度<br>4、<code>DataOutputStream</code>：用于以特定的格式写入基本数据类型数据<br>5、<code>ObjectOutputStream</code>：用用于将Java对象序列化为流</p><p>以下是使用<code>OutputStream</code>读取数据的基本步骤：<br>1、创建<code>OutputStream</code>的子类实例，比如<code>FileOutputStream</code>或<code>ByteArrayOutputStream</code><br>2、使用<code>write(byte[] data)</code>方法将一组字节数据写入流，或使用<code>write(int b)</code>方法将单个字节数据写入流<br>3、在写入完数据后，刷新流（可选），以确保数据被写入目标<br>4、关闭输出流，释放资源，可以使用<code>clone()</code>方法实现</p><p>实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建一个FileOutputStream对象</span><br>            <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;example.txt&quot;</span>);<br>            <br>            <span class="hljs-comment">// 写入数据</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, OutputStream!&quot;</span>;<br>            <span class="hljs-type">byte</span>[] bytes = data.getBytes();<br>            outputStream.write(bytes);<br>            <br>            <span class="hljs-comment">// 刷新流（可选）</span><br>            outputStream.flush();<br>            <br>            <span class="hljs-comment">// 关闭输出流</span><br>            outputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>类似于 <code>FileInputStream</code>，<code>FileOutputStream</code> 通常也会配合 <code>BufferedOutputStream</code>来使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);<br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fileOutputStream)<br></code></pre></td></tr></table></figure><p><strong>字符输入流Reader：</strong><br><strong>字符输出流Writer:</strong></p><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰者模式（Decorator Pattern）是一种结构型设计模式，它允许你动态地将新的行为添加到对象上，同时保持对象的接口不变。装饰者模式通过创建包装对象来扩展原始对象的功能，而不需要修改原始对象的代码。</p><p>在装饰者模式中，有四个主要角色：</p><p>1、抽象组件（Component）：定义一个抽象接口，用于定义被装饰对象和装饰对象的共同行为。</p><p>2、具体组件（Concrete Component）：实现抽象组件接口，定义具体的被装饰对象。</p><p>3、抽象装饰者（Decorator）：继承或实现抽象组件接口，用于包装具体组件。它内部持有一个抽象组件的引用，并定义了与抽象组件相同的接口。</p><p>4、具体装饰者（Concrete Decorator）：继承或实现抽象装饰者接口，用于实现具体的装饰逻辑。它在调用父类方法前后，可以添加自己的额外功能。</p><p>装饰者模式的关键点是通过多层的包装（装饰）来为对象增加新的行为或功能，而不是通过继承来扩展功能。这使得装饰者模式更加灵活，可以动态地组合不同的行为，而不需要创建大量的子类</p><p>示例代码：<br>假设有一个简单的咖啡店，我们可以用装饰者模式来动态地给咖啡添加各种配料</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象组件</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Coffee</span>&#123;<br><span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//具体组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleCoffer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Coffee</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//抽象装饰者</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Coffee</span>&#123;<br><span class="hljs-keyword">protected</span> Coffee coffee;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CoffeeDecorator</span><span class="hljs-params">(Coffee coffee)</span>&#123;<br><span class="hljs-built_in">this</span>.coffee=coffee;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//具体装饰者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MilkDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CoffeeDecorator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MilkDecorator</span><span class="hljs-params">(Coffee coffee)</span> &#123;<br>        <span class="hljs-built_in">super</span>(coffee);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> coffee.cost() + <span class="hljs-number">0.5</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SugarDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CoffeeDecorator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SugarDecorator</span><span class="hljs-params">(Coffee coffee)</span> &#123;<br>        <span class="hljs-built_in">super</span>(coffee);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> coffee.cost() + <span class="hljs-number">0.2</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorPatternExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个简单咖啡对象</span><br>        <span class="hljs-type">Coffee</span> <span class="hljs-variable">simpleCoffee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleCoffee</span>();<br>        System.out.println(<span class="hljs-string">&quot;Cost of simple coffee: &quot;</span> + simpleCoffee.cost());<br><br>        <span class="hljs-comment">// 给咖啡添加牛奶</span><br>        <span class="hljs-type">Coffee</span> <span class="hljs-variable">coffeeWithMilk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MilkDecorator</span>(simpleCoffee);<br>        System.out.println(<span class="hljs-string">&quot;Cost of coffee with milk: &quot;</span> + coffeeWithMilk.cost());<br><br>        <span class="hljs-comment">// 给咖啡添加糖</span><br>        <span class="hljs-type">Coffee</span> <span class="hljs-variable">coffeeWithMilkAndSugar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SugarDecorator</span>(coffeeWithMilk);<br>        System.out.println(<span class="hljs-string">&quot;Cost of coffee with milk and sugar: &quot;</span> + coffeeWithMilkAndSugar.cost());<br>    &#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Cost of simple coffee: <span class="hljs-number">1.0</span><br>Cost of coffee with milk: <span class="hljs-number">1.5</span><br>Cost of coffee with milk and sugar: <span class="hljs-number">1.7</span><br></code></pre></td></tr></table></figure><h4 id="在Java的IO流中，装饰者模式的使用"><a href="#在Java的IO流中，装饰者模式的使用" class="headerlink" title="在Java的IO流中，装饰者模式的使用"></a>在Java的IO流中，装饰者模式的使用</h4><p>Java中的IO流分为字节流和字符流，分别对应于InputStream和Reader（字节输入流）以及OutputStream和Writer（字节输出流）。这些IO流都是抽象类，而具体的IO功能由各种具体子类来实现，如FileInputStream、FileOutputStream、BufferedInputStream、BufferedOutputStream等。</p><p>装饰者模式在Java的IO流中的应用如下：</p><p>1、抽象组件：在IO流中，抽象组件就是抽象类InputStream和OutputStream或者Reader和Writer，它们定义了所有具体组件和装饰者的共同接口。</p><p>2、具体组件：具体组件是抽象组件的实现类，如FileInputStream和FileOutputStream等。</p><p>3、抽象装饰者：在IO流中，抽象装饰者是FilterInputStream和FilterOutputStream或者Reader和Writer的抽象子类，它们也是抽象类，继承自抽象组件。它内部持有一个抽象组件的引用，同时定义了与抽象组件相同的接口。</p><p>4、具体装饰者：具体装饰者是抽象装饰者的实现类，如BufferedInputStream和BufferedOutputStream等。它继承自抽象装饰者，用于实现具体的装饰逻辑。</p><p>在Java的IO流中，装饰者模式允许我们通过组合不同的具体装饰者，来动态地扩展IO流的功能。比如，我们可以通过将FileInputStream包装在BufferedInputStream中，再包装在DataInputStream中，从而实现对文件的缓冲读取和数据解析等功能。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorPatternInIO</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(inputStream);<br>            <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dataInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(bufferedInputStream);<br><br>            <span class="hljs-comment">// 使用装饰后的DataInputStream读取数据</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> dataInputStream.readInt();<br>            System.out.println(<span class="hljs-string">&quot;Data read from input.txt: &quot;</span> + data);<br><br>            dataInputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，我们通过装饰者模式将FileInputStream包装在BufferedInputStream中，再包装在DataInputStream中，实现了对文件的缓冲读取和数据解析功能。这样，我们可以通过不同的组合，来实现不同的IO功能</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2023/07/21/SQL/"/>
    <url>/2023/07/21/SQL/</url>
    
    <content type="html"><![CDATA[<h2 id="group-concat函数"><a href="#group-concat函数" class="headerlink" title="group-concat函数"></a>group-concat函数</h2><p><code>GROUP_CONCAT</code> 函数是一种在关系型数据库中用于合并（连接）多行数据的聚合函数。它常常与 <code>GROUP BY</code> 子句一起使用，用于将同一组的多行数据合并成单一的字符串值 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ClassId, GROUP_CONCAT(StudentName) <span class="hljs-keyword">AS</span> Students<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ClassId;<br><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+-----------------------------+</span><br><span class="hljs-operator">|</span> ClassId <span class="hljs-operator">|</span> Students                    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+-----------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1</span>       <span class="hljs-operator">|</span> John, Alice, Bob            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">2</span>       <span class="hljs-operator">|</span> Mary, James                 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3</span>       <span class="hljs-operator">|</span> Sarah, Michael, Jessica     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+-----------------------------+</span><br><br></code></pre></td></tr></table></figure><p> 上面的 SQL 查询将根据 <code>ClassId</code> 列对学生数据进行分组，并使用 <code>GROUP_CONCAT</code> 函数将同一班级的学生姓名合并成一个字符串，并以逗号分隔各个姓名 </p><h2 id="列转行、行转列"><a href="#列转行、行转列" class="headerlink" title="列转行、行转列"></a>列转行、行转列</h2><p>列转行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> product_id, <span class="hljs-string">&#x27;store1&#x27;</span> store, store1 price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> store1 <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> product_id, <span class="hljs-string">&#x27;store2&#x27;</span> store, store2 price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> store2 <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> product_id, <span class="hljs-string">&#x27;store3&#x27;</span> store, store3 price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> store3 <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><p>行转列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>  product_id,<br>  <span class="hljs-built_in">SUM</span>(IF(store <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;store1&#x27;</span>, price, <span class="hljs-keyword">NULL</span>)) <span class="hljs-string">&#x27;store1&#x27;</span>,<br>  <span class="hljs-built_in">SUM</span>(IF(store <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;store2&#x27;</span>, price, <span class="hljs-keyword">NULL</span>)) <span class="hljs-string">&#x27;store2&#x27;</span>,<br>  <span class="hljs-built_in">SUM</span>(IF(store <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;store3&#x27;</span>, price, <span class="hljs-keyword">NULL</span>)) <span class="hljs-string">&#x27;store3&#x27;</span> <br><span class="hljs-keyword">FROM</span><br>  Products1 <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> product_id ;<br></code></pre></td></tr></table></figure><h2 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users<br><span class="hljs-keyword">where</span> mail REGEXP <span class="hljs-string">&#x27;^[a-zA-Z][a-zA-Z0-9\_\.\-]*@leetcode\.com$&#x27;</span><br>要用到关键字 REGEXP<br></code></pre></td></tr></table></figure><h2 id="筛选时间"><a href="#筛选时间" class="headerlink" title="筛选时间"></a>筛选时间</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">对年份的筛选:<span class="hljs-number">2020</span>年（月日同理）<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">year</span>(time_stamp) <span class="hljs-operator">=</span> <span class="hljs-number">2020</span> <br><span class="hljs-keyword">where</span> time_stamp <span class="hljs-keyword">like</span> &quot;2020%&quot;<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">LEFT</span>(time_stamp, <span class="hljs-number">4</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2020&#x27;</span><br><span class="hljs-keyword">where</span> substr(time_stamp,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2020&#x27;</span><br>datediff(time_stamp, <span class="hljs-string">&#x27;2020-01-01&#x27;</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> datediff(time_stamp, <span class="hljs-string">&#x27;2020-12-31&#x27;</span>) <span class="hljs-operator">&lt;=</span> <span class="hljs-number">0</span> <br><span class="hljs-keyword">where</span> time_stamp <span class="hljs-keyword">between</span> <span class="hljs-string">&#x27;2020-01-01 00:00:00&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;2020-12-31 23:59:59&#x27;</span><br><span class="hljs-keyword">where</span>(time_stamp <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2020-01-01 00:00:00&#x27;</span> <span class="hljs-keyword">and</span> time_stamp <span class="hljs-operator">&lt;=</span> <span class="hljs-string">&#x27;2020-12-31 23:59:59&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在使用between来限定时间时，默认会进行格式化，格式化为 00:00:00，23:59:59</p><h2 id="CASE-WHEN使用"><a href="#CASE-WHEN使用" class="headerlink" title="CASE WHEN使用"></a>CASE WHEN使用</h2><ol><li>简单的 CASE WHEN：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> column1,<br>       column2,<br>       <span class="hljs-keyword">CASE</span> column3<br>           <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Apple&#x27;</span><br>           <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;B&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Banana&#x27;</span><br>           <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;C&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Cherry&#x27;</span><br>           <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;Unknown&#x27;</span><br>       <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> column3_alias<br><span class="hljs-keyword">FROM</span> table_name;<br><br></code></pre></td></tr></table></figure><p>2.搜索条件中带有运算符的 CASE WHEN：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> column1,<br>       column2,<br>       <span class="hljs-keyword">CASE</span><br>           <span class="hljs-keyword">WHEN</span> column3 <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Positive&#x27;</span><br>           <span class="hljs-keyword">WHEN</span> column3 <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Negative&#x27;</span><br>           <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;Zero&#x27;</span><br>       <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> column3_status<br><span class="hljs-keyword">FROM</span> table_name;<br><br></code></pre></td></tr></table></figure><h2 id="IFNULL函数"><a href="#IFNULL函数" class="headerlink" title="IFNULL函数"></a>IFNULL函数</h2><p>IFNULL() 函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值，如果不为 NULL 则返回第一个参数的值。</p><p>IFNULL() 函数语法格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">IFNULL(expression, alt_value)<br></code></pre></td></tr></table></figure><h2 id="窗口函数-DENSE-RANK"><a href="#窗口函数-DENSE-RANK" class="headerlink" title="窗口函数 DENSE_RANK()"></a>窗口函数 <code>DENSE_RANK()</code></h2><p><img src="/image/Database/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> score,<br><span class="hljs-built_in">dense_rank</span>() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;Rank&#x27;</span><br><span class="hljs-keyword">from</span> Scores<br><br><span class="hljs-built_in">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;Rank&#x27;</span>：这是一个窗口函数 <span class="hljs-built_in">DENSE_RANK</span>()，它计算在分数列上的密集排名。使用 <span class="hljs-keyword">OVER</span>() 子句指定排序顺序，这里是按照分数列降序排列。<span class="hljs-built_in">DENSE_RANK</span>() 函数将为每个分数分配一个排名值，相同的分数将获得相同的排名值。<br></code></pre></td></tr></table></figure><h2 id="数据库索引的失效"><a href="#数据库索引的失效" class="headerlink" title="数据库索引的失效"></a>数据库索引的失效</h2><ul><li>检索字段采用以“%”开头的模糊查询时索引会失效</li><li>使用OR时会失效，如果要使用OR那么OR两边的字段都必须有索引，索引才会生效。使用union，union不会让索引失效</li><li>使用复合索引时没有使用左侧的列查找，索引失效(违背了最左匹配原则)</li><li>当where当中索引列参加了运算，索引会失效</li><li>在where当中索引列使用了函数，索引失效</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2023/07/21/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/07/21/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="多态的执行顺序"><a href="#多态的执行顺序" class="headerlink" title="多态的执行顺序"></a>多态的执行顺序</h2><ul><li>多态中成员方法使用规则：编译看左边，运行看右边</li><li>多态中，子类重写的方法，当super调用就是调用父类方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//假定Base b = new Derived（）; 调用执行b.methodOne（）后，输出结果是什么？</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodOne</span><span class="hljs-params">()</span><br>   &#123;<br>      System.out.print(<span class="hljs-string">&quot;A&quot;</span>);   <span class="hljs-comment">//3.输出A</span><br>      methodTwo();             <span class="hljs-comment">//4.未被super调用，使用子类重写方法methodTwo()方法</span><br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodTwo</span><span class="hljs-params">()</span><br>   &#123;<br>      System.out.print(<span class="hljs-string">&quot;B&quot;</span>);  <span class="hljs-comment">//6.输出B</span><br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span><br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodOne</span><span class="hljs-params">()</span>     <span class="hljs-comment">//1</span><br>   &#123;<br>      <span class="hljs-built_in">super</span>.methodOne();       <span class="hljs-comment">//2.super调用，使用父类methodOne（）方法</span><br>      System.out.print(<span class="hljs-string">&quot;C&quot;</span>);<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodTwo</span><span class="hljs-params">()</span><br>   &#123;<br>      <span class="hljs-built_in">super</span>.methodTwo();       <span class="hljs-comment">//5.super调用，使用父类methodTwo()方法</span><br>      System.out.print(<span class="hljs-string">&quot;D&quot;</span>);   <span class="hljs-comment">//7.输出D</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>().getValue());<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span> <span class="hljs-params">(<span class="hljs-type">int</span> v)</span> &#123;<br>            setValue(v);<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value= value;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                value ++;<br>                <span class="hljs-keyword">return</span> value;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-built_in">this</span>.setValue(value);<br>                System.out.println(value);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span> <span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">super</span>(<span class="hljs-number">5</span>);<br>            setValue(getValue()- <span class="hljs-number">3</span>);<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>            <span class="hljs-built_in">super</span>.setValue(<span class="hljs-number">2</span> * value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/Javase/%E5%A4%9A%E6%80%81%E7%9A%84%E6%89%A7%E8%A1%8C.png"></p><h2 id="在继承关系中类加载的顺序"><a href="#在继承关系中类加载的顺序" class="headerlink" title="在继承关系中类加载的顺序"></a>在继承关系中类加载的顺序</h2><p>假设有以下的父类和子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">Copy code<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    Parent() &#123;<br>        System.out.println(<span class="hljs-string">&quot;Parent constructor&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">parentMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Parent method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    Child() &#123;<br>        System.out.println(<span class="hljs-string">&quot;Child constructor&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">childMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Child method&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>加载类信息：</strong> 当你使用<code>new Child()</code>创建子类的实例时，Java虚拟机(JVM)首先会加载<code>Parent</code>和<code>Child</code>类的信息。这包括加载类的字节码、静态成员和静态代码块等。注意，这并不意味着实际创建了对象，而是将类的信息加载到内存中供后续使用。</p><p><strong>初始化父类：</strong> 在加载子类之前，必须先初始化父类。这意味着父类的静态成员和静态代码块会被执行，且仅执行一次。如果父类还有父类（即多级继承），则会按照继承层次依次初始化父类。</p><p>输出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">kotlin<br><span class="hljs-keyword">Copy</span> code<br>Parent <span class="hljs-keyword">constructor</span><br></code></pre></td></tr></table></figure><p><strong>初始化子类：</strong> 当父类被初始化后，再初始化子类。同样，子类的静态成员和静态代码块会被执行且仅执行一次。</p><p>输出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">kotlin<br><span class="hljs-keyword">Copy</span> code<br>Parent <span class="hljs-keyword">constructor</span><br><span class="hljs-title function_">Child</span> <span class="hljs-title function_">constructor</span><br></code></pre></td></tr></table></figure><p><strong>创建对象实例：</strong> 初始化完成后，JVM会为Child类创建一个对象实例。此时，会调用<code>Child</code>类的构造方法。注意，在构造方法的第一行，会隐式地调用父类的无参数构造方法（如果没有显式调用其他父类构造方法）。</p><p>输出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">kotlin<br><span class="hljs-keyword">Copy</span> code<br>Parent <span class="hljs-keyword">constructor</span><br><span class="hljs-title function_">Child</span> <span class="hljs-title function_">constructor</span><br></code></pre></td></tr></table></figure><p><strong>调用构造方法：</strong> 子类的构造方法被调用，构造过程向上逐级进入父类的构造方法，直至达到顶层的父类。这确保了父类中的所有构造方法都得到执行。</p><p>输出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">kotlin<br><span class="hljs-keyword">Copy</span> code<br>Parent <span class="hljs-keyword">constructor</span><br><span class="hljs-title function_">Child</span> <span class="hljs-title function_">constructor</span><br></code></pre></td></tr></table></figure><p><strong>实例化成员：</strong> 在构造方法中定义的实例变量初始化和实例代码块会被执行。此时，实例变量和实例代码块按照声明顺序依次执行。</p><p><strong>对象初始化完成：</strong> 构造方法执行完成后，子类的对象初始化过程完成，现在可以使用该对象进行操作。</p><p>总结起来，方法的加载和调用顺序如下：</p><ul><li>加载父类信息</li><li>初始化父类静态成员和静态代码块</li><li>加载子类信息</li><li>初始化子类静态成员和静态代码块</li><li>创建子类对象实例</li><li>调用父类的构造方法（沿继承链向上逐级执行）</li><li>调用子类的构造方法</li><li>实例化成员和执行实例代码块</li><li>对象初始化完成</li></ul><h2 id="异常代码段中值的返回"><a href="#异常代码段中值的返回" class="headerlink" title="异常代码段中值的返回"></a>异常代码段中值的返回</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(test()); <span class="hljs-comment">//2</span><br> <br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(temp);  <span class="hljs-comment">//第一步：1</span><br>            <span class="hljs-keyword">return</span> ++temp; <span class="hljs-comment">//返回2，但不是直接返回，而是先放到临时空间中，等finally代码块代码执行完再返回</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(temp);<br>            <span class="hljs-keyword">return</span> ++temp;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ++temp;<br>            System.out.println(temp);  <span class="hljs-comment">//3</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> finally代码块在return中间执行。return的值会被放入临时空间，然后执行finally代码块，如果finally中有return，会刷新临时空间的值，方法结束返回临时空间值 </p><p>当出现多个catch块时，应该先处理小异常，再处理大异常，也就是把父类异常的catch块放到处理子类异常的catch块之后</p><h2 id="throws和throw的区分"><a href="#throws和throw的区分" class="headerlink" title="throws和throw的区分"></a>throws和throw的区分</h2><p>throws关键字可以在方法上声明该方法要抛出的异常<br>throw用于抛出异常对象</p><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><p><img src="/image/Javase/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png"></p><h2 id="equals方法注意事项"><a href="#equals方法注意事项" class="headerlink" title="equals方法注意事项"></a>equals方法注意事项</h2><p>使用equals方法对对象内容进行比较时，要注意比较的双方应该是同一数据类型</p><p>在使用equals方法时要避免空指针异常</p><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p>序列化：将数据结构转换成为二进制数据流或者文本流的过程，将数据长久的保存在磁盘里面（序列化是将数据转为n个byte序列的过程）</p><p>反序列化：与序列化相反，是将二进制数据流或者文本流转换称为易于处理和阅读的数据结构的过程（反序列化是将n个 byte转换为数据的过程）</p><p>序列化的方式：实现序列化接口： Serializable ，使用transient关键字修饰变量不能被序列化，static变量不管有没有加transient都不可以被序列化</p><h2 id="数据类型的转变"><a href="#数据类型的转变" class="headerlink" title="数据类型的转变"></a>数据类型的转变</h2><p>只要两个操作数中有一个是double类型的，另一个将会被转换成double类型，并且结果也是double类型，如果两个操作数中有一个是float类型的，另一个将会被转换为float类型，并且结果也是float类型，如果两个操作数中有一个是long类型的，另一个将会被转换成long类型，并且结果也是long类型，否则（操作数为：byte、short、int 、char），两个数都会被转换成int类型，并且结果也是int类型。 </p><p>在数据类型的转换中：由大到小需要强制转换，由小到大不需要</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li>构造方法的名字必须和类名一致</li><li>构造方法没有返回值，返回的是一个类，也不能用void修饰</li><li>构造方法不能是抽象的、静态的、最终的、同步的也就是说，他不能通过abstract、static、final、synchronized关键字修饰</li></ul><h2 id="实例变量、类变量、局部变量"><a href="#实例变量、类变量、局部变量" class="headerlink" title="实例变量、类变量、局部变量"></a>实例变量、类变量、局部变量</h2><p>实例变量： 也叫对象变量、类成员变量；从属于类由类生成对象时，才分配存储空间，各对象间的实例变量互不干扰，能通过对象的引用来访问实例变量 </p><p>类变量： 也叫静态变量，是一种比较特殊的实例变量，用static关键字修饰；一个类的静态变量，所有由这类生成的对象都共用这个类变量，类装载时就分配存储空间。一个对象修改了变量，则所以对象中这个变量的值都会发生改变。 </p><p>局部变量： 方法中或者某局部块中声明定义的变量或方法的参数被称为局部变量 </p><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><ul><li><p>接口是行为的抽象，是一种行为的规范，接口是like a的关系；抽象是对类的抽象，是一种模板设计，抽象类是is a的关系</p></li><li><p>接口没有构造方法，而抽象类有构造方法</p></li><li><p>接口可以多实现，但抽象类只能单继承</p></li><li><p>接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public abstract的。抽象类中成员变量默认是default，可在子类中被重新定义，也可以被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不能带花括号。</p><p>注：JDK1.8中对接口增加了新的特性</p></li><li><p>默认方法（default method）：JDK1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义的默认方法可以不被子类所实现，但只能被实现的子类的对象所调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；</p></li><li><p>静态方法（static method）：JDK1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）</p></li></ul><h2 id="GC垃圾回收器"><a href="#GC垃圾回收器" class="headerlink" title="GC垃圾回收器"></a>GC垃圾回收器</h2><p>垃圾回收器只针对Java堆进行垃圾回收， 堆用于存放所有对象，是线程共享的 </p><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="&gt;&gt;和&gt;&gt;&gt;的区别"></a>&gt;&gt;和&gt;&gt;&gt;的区别</h2><p><code>&gt;&gt;</code>(带符号右移)：<br>带符号右移位操作符。它将二进制数向右移动指定的位数，并用原来符号位的值填充左侧空出的位。如果原来是正数，则在左侧填充0；如果原来是负数，则在左侧填充1。这意味着使用 <code>&gt;&gt;</code> 右移后，负数仍然是负数，而正数仍然是正数<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> -<span class="hljs-number">16</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> num &gt;&gt; <span class="hljs-number">2</span>;<br>System.out.println(result); <span class="hljs-comment">// 输出 -4</span><br></code></pre></td></tr></table></figure><p>-16 的二进制表示为 11111111 11111111 11111111 11110000，右移2位后，得到 11111111 11111111 11111111 11111100，转换为十进制即为 -4</p><p><code>&gt;&gt;&gt;</code>(无符号右移)：<br>无符号右移位操作符。它将二进制数向右移动指定的位数，并用0填充左侧空出的位，忽略了符号位的影响。使用<code>&gt;&gt;&gt;</code>右移后，无论原来的数是正数还是负数，结果都是非负数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> -<span class="hljs-number">16</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> num &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>System.out.println(result); <span class="hljs-comment">// 输出 1073741820</span><br></code></pre></td></tr></table></figure><p>-16 的二进制表示为 11111111 11111111 11111111 11110000，右移2位后，得到 00111111 11111111 11111111 11111100，转换为十进制即为 1073741820</p><h2 id="Java中创建对象的方式"><a href="#Java中创建对象的方式" class="headerlink" title="Java中创建对象的方式"></a>Java中创建对象的方式</h2><p>例如，假设有一个名为<code>Person</code>的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>,<span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他方法和属性...</span><br>     <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone(); <span class="hljs-comment">// 默认实现为浅拷贝</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，可以使用以下方法创建<code>Person</code>类的对象：<br>1、用new语句创建对象，是最常见的创建对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br><span class="hljs-type">Person</span> <span class="hljs-variable">person2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>);<br></code></pre></td></tr></table></figure><p>2、运用反射手段，调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    Class&lt;?&gt; personClass = Class.forName(<span class="hljs-string">&quot;com.example.Person&quot;</span>);<br>    Constructor&lt;?&gt; constructor = personClass.getConstructor(String.class, <span class="hljs-type">int</span>.class);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) constructor.newInstance(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>3、调用对象的clone()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用clone()方法创建对象的副本</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br><span class="hljs-type">Person</span> <span class="hljs-variable">person2</span> <span class="hljs-operator">=</span> (Person) person1.clone();<br></code></pre></td></tr></table></figure><p>4、运用反序列手段，调用java.io.ObjectInputStream对象的readObject()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用反序列化手段创建对象的副本</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br><br><span class="hljs-comment">// 序列化对象到文件</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;person.ser&quot;</span>))) &#123;<br>    oos.writeObject(person1);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><br><span class="hljs-comment">// 从文件反序列化对象</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">person2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;person.ser&quot;</span>))) &#123;<br>    person2 = (Person) ois.readObject();<br>&#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>    e.printStackTrace();<br></code></pre></td></tr></table></figure><h2 id="Java中的值传递和引用传递"><a href="#Java中的值传递和引用传递" class="headerlink" title="Java中的值传递和引用传递"></a>Java中的值传递和引用传递</h2><p>1、值传递：<br>在值传递中，当我们将一个基本数据类型（如 int、float、char 等）或一个对象的引用作为方法的参数传递时，实际上是将参数的值（基本类型的值或引用的副本）传递给了方法。在方法内对参数进行修改不会影响原始的参数</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByValueExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        modifyValue(x);<br>        System.out.println(x); <span class="hljs-comment">// 输出 10，原始的参数 x 没有被修改</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        value = <span class="hljs-number">20</span>; <span class="hljs-comment">// 修改形参 value 的值，不会影响原始的参数 x</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、引用传递：<br>引用传递是指当我们将一个对象作为方法的参数传递时，实际上传递的是对象的引用（内存地址）。在方法内部，对传递的对象进行修改将影响到原始对象，因为它们都指向同一块内存地址</p><p>但需要注意的是，虽然在方法内部可以修改对象的状态，但如果在方法内部将参数指向一个新的对象，原始对象不会受到影响。因为传递的是引用的副本，修改副本的引用并不会改变原始引用</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByReferenceExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        modifyReference(str);<br>        System.out.println(str); <span class="hljs-comment">// 输出 &quot;Hello, World!&quot;，原始的对象被修改</span><br><br>        assignNewReference(str);<br>        System.out.println(str); <span class="hljs-comment">// 输出 &quot;Hello, World!&quot;，原始的引用未改变</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyReference</span><span class="hljs-params">(StringBuilder builder)</span> &#123;<br>        builder.append(<span class="hljs-string">&quot;, World!&quot;</span>); <span class="hljs-comment">// 修改传入的对象，影响原始对象</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">assignNewReference</span><span class="hljs-params">(StringBuilder builder)</span> &#123;<br>        builder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;New String&quot;</span>); <span class="hljs-comment">// 将参数指向新的对象，不会影响原始对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 中参数传递都是按值传递的，但是对于对象类型的参数，传递的是对象引用的副本。这意味着在方法内部可以修改对象的状态，但无法通过修改对象引用来改变原始引用所指向的对象</p><h2 id="Java的内部类"><a href="#Java的内部类" class="headerlink" title="Java的内部类"></a>Java的内部类</h2><p>1、成员内部类：<br>成员内部类是最普通的内部类。它定义在一个类的内部，作为该类的成员之一。成员内部类可以访问外部类的成员（包括私有成员），并且可以使用外部类的引用来访问 它们</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-comment">// 外部类的成员和方法</span><br><br>    <span class="hljs-comment">// 成员内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123;<br>        <span class="hljs-comment">// 内部类的成员和方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、静态内部类：<br>静态内部类是一个静态成员，它类似于一个普通类，但是它定义在另一个类的内部。与成员内部类不同，静态内部类不持有对外部类的引用，因此无法直接访问外部类的非静态成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-comment">// 外部类的成员和方法</span><br><br>    <span class="hljs-comment">// 静态内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticInnerClass</span> &#123;<br>        <span class="hljs-comment">// 内部类的成员和方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、方法内部类：<br>方法内部类定义在方法内部，只能在该方法的作用域内使用。与成员内部类和静态内部类不同，方法内部类不能有访问修饰符和静态修饰符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 方法内部类</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodInnerClass</span> &#123;<br>            <span class="hljs-comment">// 内部类的成员和方法</span><br>        &#125;<br><br>        <span class="hljs-comment">// 使用方法内部类</span><br>        <span class="hljs-type">MethodInnerClass</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodInnerClass</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、匿名内部类：<br>匿名内部类是没有显示定义类名的内部类。它通常用于实现接口或继承一个类的抽象方法。由于没有类名，所以只能在创建它的地方使用一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 匿名内部类实现接口</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// 匿名内部类的实现</span><br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 使用匿名内部类</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="PreparedStatement和Statement的区别"><a href="#PreparedStatement和Statement的区别" class="headerlink" title="PreparedStatement和Statement的区别"></a>PreparedStatement和Statement的区别</h2><p>1、预编译与执行时编译：</p><ul><li><code>Statement</code>是一种普通的SQL语句执行接口。当使用<code>Statement</code>执行SQL语句时，每次都需要将SQL语句发送给数据库进行编译和执行.这意味着每次执行都要重新编译一次SQL语句，有一定的性能损耗</li><li><code>PreparedStatement</code>是<code>Statement</code>的子接口。在创建<code>PreparedStatement</code>对象时，数据库会预先编译SQL语句，并对其进行优化。这样，在之后的执行中，只需要传递参数就可以直接执行预编译过的SQL语句，避免了重复编译的开销，提高了执行效率</li></ul><p>2、参数绑定:</p><ul><li>在<code>Statement</code>中，如果要执行带有参数的SQL语句，需要通过字符串拼接将参数值嵌入到SQL语句中。这样做可能会引起SQL注入等安全问题</li><li>在<code>PreparedStatement</code>中，SQL语句中的参数使用占位符（如<code>?</code>）来代替实际的参数值。在执行之前，通过方法<code>setXXX</code>（例如s<code>etString</code>、<code>setInt</code>等）为每个参数绑定具体的值，这样可以更安全地传递参数，也更容易维护SQL语句</li></ul><p>3、性能：</p><ul><li>由于<code>PreparedStatement</code>的预编译特性，它在执行多次相似的SQL语句时，通常比<code>Statement</code>具有更好的性能。预编译过程只需要进行一次，然后可以重复执行多次，降低了数据库的负担</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="2023-6-5"><a href="#2023-6-5" class="headerlink" title="2023.6.5"></a>2023.6.5</h1><h2 id="HTTP协议、TCP协议、UDP协议"><a href="#HTTP协议、TCP协议、UDP协议" class="headerlink" title="HTTP协议、TCP协议、UDP协议"></a>HTTP协议、TCP协议、UDP协议</h2><p> HTTP（Hypertext Transfer Protocol）是一种用于在Web浏览器和Web服务器之间传输数据的协议。它是一种无状态的、面向请求&#x2F;响应的协议，用于客户端和服务器之间的通信。  HTTP协议是基于TCP&#x2F;IP协议栈的<strong>应用层协议</strong>，通过在TCP连接上发送和接收HTTP报文来实现通信。它使用明文传输，不提供加密和身份验证，因此可以通过使用HTTPS（HTTP Secure）来提供加密和安全性。 </p><p>TCP是一种<strong>面向连接</strong>的、可靠的<strong>传输层协议</strong>，它负责将数据可靠地传输给目标主机。TCP提供了数据分段、重传、流量控制和拥塞控制等功能，以确保数据的可靠传输。当使用HTTP时，HTTP请求和响应数据被分割成多个TCP段，然后通过TCP连接传输。</p><p>UDP是一种<strong>面向无连接</strong>的传输层协议，它不保证数据的可靠传输。UDP更注重传输效率和速度，适用于那些对数据传输的实时性要求较高的应用场景。与TCP不同，UDP不提供可靠性和流量控制等功能。由于HTTP需要可靠性，因此很少直接使用UDP作为传输层协议，而是使用TCP来传输HTTP数据。</p><p> HTTP协议使用TCP作为底层传输协议，以实现可靠的数据传输。TCP负责将HTTP请求和响应分割成数据段，并在网络上将它们传输到目标主机。UDP则通常不直接用于HTTP通信，因为它不提供可靠性保证 </p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程</title>
    <link href="/2023/07/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/07/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Java多线程设计模式"><a href="#Java多线程设计模式" class="headerlink" title="Java多线程设计模式"></a>Java多线程设计模式</h2><h3 id="顺序、并发与并行"><a href="#顺序、并发与并行" class="headerlink" title="顺序、并发与并行"></a>顺序、并发与并行</h3><p>顺序：表示多个操作“依次处理”</p><p>并行：表示多个操作“同时处理”</p><p>并发：表示多个操作“间隔进行”</p><p> 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的。 </p><p> 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。 </p><h3 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h3><p><strong>开启多线程的方法是start()而不是run()</strong></p><h4 id="利用Thread类的子类的实例启动线程"><a href="#利用Thread类的子类的实例启动线程" class="headerlink" title="利用Thread类的子类的实例启动线程"></a>利用Thread类的子类的实例启动线程</h4><p>创建一个继承自Thread类的子类，并重写其run()方法。在run()方法中定义线程要执行的代码。然后创建该子类的实例，并调用start()方法启动线程。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程执行的代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="利用Runnable接口的实现类的实例启动线程"><a href="#利用Runnable接口的实现类的实例启动线程" class="headerlink" title="利用Runnable接口的实现类的实例启动线程"></a>利用Runnable接口的实现类的实例启动线程</h4><p>创建一个实现Runnable接口的类，并实现其run()方法。在run()方法中定义线程要执行的代码。然后创建该类的实例，并将其作为参数传递给Thread类的构造函数，最后调用start()方法启动线程。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程执行的代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>        thread.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Thread类本身还实现了Runnable接口，并且持有run方法，但Thread类的run方法主体是空的，不执行任何操作。</p><h4 id="java-util-concurrent-ThreadFactory中的线程创建"><a href="#java-util-concurrent-ThreadFactory中的线程创建" class="headerlink" title="java.util.concurrent.ThreadFactory中的线程创建"></a>java.util.concurrent.ThreadFactory中的线程创建</h4><p>java.util.concurrent包中包含一个将线程创建抽象化的ThreadFactory接口。利用该接口，我们可以将Runnable作为参数并通过new创建Thread实例的处理隐藏在ThreadFactory内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建线程工厂</span><br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> Executors.defaultThreadFactory();<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread running: &quot;</span> + Thread.currentThread().getName());<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> threadFactory.newThread(task);<br>        thread.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="线程的暂停"><a href="#线程的暂停" class="headerlink" title="线程的暂停"></a>线程的暂停</h3><p>线程Thread类中的sleep方法能够暂停线程运行。sleep方法是Thread类的静态方法</p><p><img src="/image/GUI/sleep%E6%96%B9%E6%B3%95.png"></p><h3 id="线程的互斥"><a href="#线程的互斥" class="headerlink" title="线程的互斥"></a>线程的互斥</h3><h4 id="synchronized方法"><a href="#synchronized方法" class="headerlink" title="synchronized方法"></a>synchronized方法</h4><p>如果声明一个方法时，在前面加上关键字synchronized，那么这个方法每次就只能由一个线程运行。这种方法称为synchronized方法，有时也称为同步方法</p><p><img src="/image/GUI/synchronized1.png"></p><p><img src="/image/GUI/synchronized2.png"></p><p><img src="/image/GUI/synchronized3.png"></p><p>每一个实例拥有一个独立的锁。因此，并不是说某一个实例中synchronized方法正在执行中，其他实例中的synchronized方法就不可以运行了</p><p>synchronized方法与synchronized代码块</p><p><img src="/image/GUI/synchronized%E6%96%B9%E6%B3%95.png"></p><h3 id="线程的协作"><a href="#线程的协作" class="headerlink" title="线程的协作"></a>线程的协作</h3><p>Java提供了用于执行线程控制的wait方法、notify方法和notifyAll方法。wait是让线程等待的方法，而notify方法和notifyAll方法是唤醒等待中的线程的方法</p><h5 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h5><p>所有实例都拥有一个等待队列，它是在实例的wait方法执行后停止操作的线程的队列。</p><p>执行wait方法后，线程便会暂停操作，进入等待队列这个休息室。除非发生以下情况，否则线程会一直在等待队列中休眠</p><ul><li><p>有其他线程的notify方法来唤醒线程</p></li><li><p>有其他线程的notifyAll方法来唤醒线程</p></li><li><p>有其他线程的interrupt方法来唤醒线程</p></li><li><p>wait方法超时</p><p>wait方法：</p><p><img src="/image/GUI/wait%E6%96%B9%E6%B3%95.png"></p></li></ul><p>notify方法：</p><p><img src="/image/GUI/notify%E6%96%B9%E6%B3%95.png"></p><p>notify方法唤醒的线程并不会在执行notify的一瞬间重新运行。因为在执行notify的那一瞬间，执行notify方法的线程还持有着锁，所以其他线程还无法获取这个实例的锁</p><p>notifyAll方法：</p><p><img src="/image/GUI/notifyAll%E6%96%B9%E6%B3%95.png"></p><h3 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h3><ol><li>悲观锁（Pessimistic Locking）：悲观锁假设在并发环境中会出现频繁的冲突，因此在访问共享资源之前会将其加锁，确保同一时间只有一个线程可以访问。Java中的synchronized关键字和ReentrantLock就是悲观锁的实现。</li><li>乐观锁（Optimistic Locking）：乐观锁认为在并发环境中冲突的概率较低，因此不立即加锁，而是在更新资源时进行冲突检测。如果检测到冲突，乐观锁会进行回退并重试，直到没有冲突为止。Java中的StampedLock是一种乐观锁的实现。</li><li>自旋锁（Spin Lock）：如果持有锁的线程在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态的切换进入阻塞挂起状态，他们只需要等一等，等待持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗，但是也加大了CPU资源的浪费</li></ol><h3 id="线程的阻塞状态"><a href="#线程的阻塞状态" class="headerlink" title="线程的阻塞状态"></a>线程的阻塞状态</h3><ol><li>等待阻塞（o.wait-&gt;等待队列）</li><li>同步阻塞（lock-&gt;锁池）运行的线程在获取对象的同步锁时，若该同步线程被别的线程占用，则JVM会把该线程放到锁池中</li><li>其他阻塞（sleep&#x2F;join）</li></ol><h3 id="线程的死亡"><a href="#线程的死亡" class="headerlink" title="线程的死亡"></a>线程的死亡</h3><ol><li>正常死亡：run（）或call（）方法执行完成，线程正常结束</li><li>异常结束：线程抛出一个未捕获的Exception或Error</li><li>调用stop：直接调用该线程的stop方法来结束线程——该方法通常容易导致死锁</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++基础知识</title>
    <link href="/2023/07/20/C++/"/>
    <url>/2023/07/20/C++/</url>
    
    <content type="html"><![CDATA[<h2 id="指针、常量指针、指针常量的区别"><a href="#指针、常量指针、指针常量的区别" class="headerlink" title="指针、常量指针、指针常量的区别"></a>指针、常量指针、指针常量的区别</h2><p>指针：可以改变它所指向的内存区域里面的值，同时也可以指向其他的内存区域</p><p>常量指针：所指向的内存地址可以发生改变，但不能改变该内存区域里面的值</p><p>指针常量：指向的内存地址不可变，但内存地址中存入的数据可以发生改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> j=<span class="hljs-number">20</span>;<br><span class="hljs-comment">//指针</span><br><span class="hljs-type">int</span>* pi=&amp;i;<br>pi=&amp;j  <span class="hljs-comment">//true</span><br>*pi=<span class="hljs-number">20</span>;<span class="hljs-comment">//true</span><br><span class="hljs-comment">//常量指针</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* pi=&amp;i;<br>pi=&amp;j  <span class="hljs-comment">//true</span><br>*pi=<span class="hljs-number">20</span>;<span class="hljs-comment">//false</span><br><span class="hljs-comment">//指针常量</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> pi=&amp;i;<br>pi=&amp;j; <span class="hljs-comment">//false</span><br>*pi=<span class="hljs-number">20</span>;<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="指针数组和数组指针的区别"><a href="#指针数组和数组指针的区别" class="headerlink" title="指针数组和数组指针的区别"></a>指针数组和数组指针的区别</h2><p>指针数组：数组</p><p>数组指针：指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>* pa[<span class="hljs-number">5</span>];  <span class="hljs-comment">//指针数组</span><br><span class="hljs-built_in">int</span>(*ap)[<span class="hljs-number">5</span>]; <span class="hljs-comment">//数组指针</span><br><br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>pa[<span class="hljs-number">0</span>] = arr;<br>cout &lt;&lt; <span class="hljs-string">&quot;pa[0]=&quot;</span> &lt;&lt; pa[<span class="hljs-number">0</span>] &lt;&lt; endl;   <span class="hljs-comment">//arr数组的内存地址也就是arr[0]的内存地址</span><br>cout &lt;&lt; <span class="hljs-string">&quot;*pa[0]=&quot;</span> &lt;&lt; *pa[<span class="hljs-number">0</span>] &lt;&lt; endl; <span class="hljs-comment">//arr[0]的值：1</span><br><br>ap = &amp;arr;<br>cout &lt;&lt; <span class="hljs-string">&quot;(*ap)=&quot;</span> &lt;&lt; *ap &lt;&lt; endl;    <span class="hljs-comment">//arr的内存地址</span><br>cout &lt;&lt; <span class="hljs-string">&quot;(*ap)[0]=&quot;</span> &lt;&lt; **ap &lt;&lt; endl; <span class="hljs-comment">//1</span><br>cout &lt;&lt; <span class="hljs-string">&quot;(*ap)[1]=&quot;</span> &lt;&lt; *(*ap+<span class="hljs-number">1</span>) &lt;&lt; endl; <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><h2 id="引用和常量引用"><a href="#引用和常量引用" class="headerlink" title="引用和常量引用"></a>引用和常量引用</h2><p>常量引用的值不能被修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> j=<span class="hljs-number">20</span>;<br><span class="hljs-type">int</span>&amp; ref=i;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; cref1=i;<span class="hljs-comment">//true</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; cref2=<span class="hljs-number">10</span>;<span class="hljs-comment">//true</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; cref3=j;<span class="hljs-comment">//true</span><br><br>ref=<span class="hljs-number">20</span>;   <span class="hljs-comment">//true</span><br>cref1=<span class="hljs-number">20</span>;  <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h2 id="引用和指针常量"><a href="#引用和指针常量" class="headerlink" title="引用和指针常量"></a>引用和指针常量</h2><p>相同点：在功能上它们是类似的</p><p>不同点：引用只是给变量起了一个别名，不会占用内存空间，但指针常量会占用内存空间</p><h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    num++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">increment</span>(value);<br>    <span class="hljs-comment">// value仍然为5，没有改变</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>值传递是指将函数参数的值复制一份传递给函数。在函数内部，对参数进行修改不会影响到原始的变量<br><span class="hljs-comment">//引用传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; num)</span> </span>&#123;<br>    num++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">increment</span>(value);<br>    <span class="hljs-comment">// value现在为6，被函数修改了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>引用传递是通过传递参数的引用而不是复制值来传递参数。这样，在函数内部对参数进行的修改会直接影响到原始变量<br></code></pre></td></tr></table></figure><h2 id="尾置返回类型"><a href="#尾置返回类型" class="headerlink" title="尾置返回类型"></a>尾置返回类型</h2><p>采用尾置返回类型的方法返回一个数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">createArray</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">int</span>* </span>&#123;<br>    <span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];  <span class="hljs-comment">// 创建一个包含5个整数的数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        arr[i] = i + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 初始化数组元素</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;  <span class="hljs-comment">// 返回数组指针</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">createArray</span>();  <span class="hljs-comment">// 调用函数并接收返回的数组指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        std::cout &lt;&lt; result[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出数组元素</span><br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] result;  <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello JVM</title>
    <link href="/2023/07/19/JVM/"/>
    <url>/2023/07/19/JVM/</url>
    
    <content type="html"><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="/image/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>程序计数器（Program Counter Register）可以看作是当前线程所执行的字节码的行号指示器</p><p><img src="/image/JVM/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.png"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>线程私有</li><li>不会存在内存溢出</li></ul><p>Java虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存</p><h2 id="JAVA虚拟机栈"><a href="#JAVA虚拟机栈" class="headerlink" title="JAVA虚拟机栈"></a>JAVA虚拟机栈</h2><p>与程序计数器一样，JAVA虚拟机栈也是线程私有的，它的生命周期与线程相同</p><p><img src="/image/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png"></p><p>每个方法被执行的时候，JAVA虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</p><p>垃圾回收是不涉及栈内存的</p><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>不共享变量不存在线程安全问题，共享变量存在线程安全问题，例如被static修饰的变量，在被多线程操作时就会出现线程安全问题</p><h3 id="内存溢出问题"><a href="#内存溢出问题" class="headerlink" title="内存溢出问题"></a>内存溢出问题</h3><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</p><p><img src="/image/JVM/StackOverflowError.png"></p><p>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常</p><p>虚拟机栈为虚拟机执行java方法（也就是字节码）服务，而本地方发栈则是为虚拟机使用到的本地方法（Native）服务</p><h2 id="Java堆（Java-Heap）"><a href="#Java堆（Java-Heap）" class="headerlink" title="Java堆（Java Heap）"></a>Java堆（Java Heap）</h2><p>Java堆(Java Heap)是虚拟机所管理内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例、</p><h3 id="内存溢出问题-1"><a href="#内存溢出问题-1" class="headerlink" title="内存溢出问题"></a>内存溢出问题</h3><p>Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”。Java堆他存在垃圾回收，但是也存在着内存溢出的问题。当新产生的对象要依赖于旧对象时，旧对象就不能被垃圾回收，如果数据量比较大，则可能存在内存溢出的问题</p><p><img src="/image/JVM/%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.png"></p><p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（TLAB），以提升对象分配时的效率。将Java堆细分的目的只是为了更好的回收内存，或者更快的分配内存</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态常量、即时编译器编译后的代码缓存等数据。</p><p><img src="/image/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E7%BB%93%E6%9E%84.png"></p><h2 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h2><p>运行时常量池是方法区的一部分</p><p>常量池表用于存放编译期生成的各种字面量与符号引用，这部分内容将在<strong>类加载后</strong>存放带方法区的运行时常量池中</p><p>运行时常量池相对于Class文件常量池的另外一个重要的特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，通过String类的intern（）方法可以将运行期间产生的常量放入池中</p><p>intern()这个方法在JDK1.6与JDK1.8有着区别：在JDK1.6中此方法将常量放入池中时会复制一份该常量，将复制的副本放入常量池中。然而在JDK1.8后放入的是该常量本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">String s1=<span class="hljs-string">&quot;a&quot;</span>;<br>String s2=<span class="hljs-string">&quot;b&quot;</span>;<br>String s3=<span class="hljs-string">&quot;ab&quot;</span>;<br>String s4=s1+s2;<span class="hljs-comment">//new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()==new String(&quot;ab&quot;)</span><br>String s5=<span class="hljs-string">&quot;a&quot;</span>+<span class="hljs-string">&quot;b&quot;</span>;<span class="hljs-comment">//s3==s5,直接在字符串池中找到&quot;ab&quot;,并不是分别找到&quot;a&quot;，&quot;b&quot;将其拼接</span><br></code></pre></td></tr></table></figure><h2 id="字符串池（StringTable）"><a href="#字符串池（StringTable）" class="headerlink" title="字符串池（StringTable）"></a>字符串池（StringTable）</h2><h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><ul><li><h3 id="调整虚拟机参数-XX-StringTableSize"><a href="#调整虚拟机参数-XX-StringTableSize" class="headerlink" title="调整虚拟机参数-XX:StringTableSize"></a>调整<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>参数-XX:StringTableSize</h3></li><li><h3 id="考虑将字符串入池"><a href="#考虑将字符串入池" class="headerlink" title="考虑将字符串入池"></a>考虑将字符串入池</h3></li></ul><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><h3 id="字符串池中的对象也会被垃圾回收器回收"><a href="#字符串池中的对象也会被垃圾回收器回收" class="headerlink" title="字符串池中的对象也会被垃圾回收器回收"></a>字符串池中的对象也会被垃圾回收器回收</h3><h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><p>在JDK1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道与缓冲区的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后用过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制</p><p><img src="/image/JVM/%E6%99%AE%E9%80%9A%E7%9A%84%E8%AF%BB%E5%8F%96%E6%96%B9%E5%BC%8F%E2%80%99.png"></p><p><img src="/image/JVM/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E2%80%98.png"></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="如何判断对象可以被回收"><a href="#如何判断对象可以被回收" class="headerlink" title="如何判断对象可以被回收"></a>如何判断对象可以被回收</h3><ol><li><p>引用计数算法：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的</p><p>缺点：难以解决对象之间相互循环引用的问题</p></li><li><p>可达性分析算法：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的</p><p><img src="/image/JVM/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png"></p><p>![](&#x2F;image&#x2F;JVM&#x2F;jvm\GC Roots.png)</p></li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><img src="/image/JVM/%E5%BC%95%E7%94%A8.png"></p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><ul><li>弱分代假说：绝大多数对象都是朝生夕灭的</li><li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡</li></ul><p><img src="/image/JVM/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png"></p><h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><ul><li><p>标记清除：Mark Sweep</p><p>速度较快，会造成内存碎片</p><p><img src="/image/JVM/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png"></p></li><li><p>标记整理算法：Mark Sweep</p><p>速度慢，不会产生内存碎片</p><p><img src="/image/JVM/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png"></p></li><li><p>复制算法：Copy</p><p>不会有内存碎片，需要占用双倍内存空间</p><p><img src="/image/JVM/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"></p></li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>串行：适用于单线程，堆内存较小 </p><p><img src="/image/JVM/%E4%B8%B2%E8%A1%8C.png"></p></li><li><p>吞吐量优先：适用于多线程，堆内存较大</p><p><img src="/image/JVM/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88.png">     </p></li><li><p>响应时间优先：适用于多线程，堆内存较大 </p><p><img src="/image/JVM/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88.png"></p></li></ul><h3 id="G1（Garbage-First）垃圾收集器"><a href="#G1（Garbage-First）垃圾收集器" class="headerlink" title="G1（Garbage First）垃圾收集器"></a>G1（Garbage First）垃圾收集器</h3><p>G1垃圾收集器它是里程石碑的垃圾收集器，它<strong>开创了面向局部收集的设计思路和基于Region内存布局形式</strong>。在JDK8Update40，G1收集器提供了并发的类卸载的支持，被Oracle公司认定为全功能的垃圾收集器</p><p>在规划JDK10的时候，HotSpot虚拟机提出了“统一垃圾收集器接口”，将内存回收的“行为”与“实现”进行分离，CMS以及其他收集器都重构成基于这套接口的一种实现（面向接口编程），这算是为CMS退出历史舞台铺下最后的道路</p><h4 id="G1收集器与CMS收集器的区别"><a href="#G1收集器与CMS收集器的区别" class="headerlink" title="G1收集器与CMS收集器的区别"></a>G1收集器与CMS收集器的区别</h4><p>CMS收集器：垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）</p><p>G1收集器：跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set）进行回收，衡量标准不再是它属于那个分代，而是那块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式</p><p>能够实现这一目标的关键是G1开创的基于Region的堆内存布局,G1不在坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</p><h4 id="Humongous区域"><a href="#Humongous区域" class="headerlink" title="Humongous区域"></a>Humongous区域</h4><p>专门存储大对象，G1认为只要大小超过一个Region容量一半的对象即可判定为大对象。对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</p><h4 id="G1收集器高效率"><a href="#G1收集器高效率" class="headerlink" title="G1收集器高效率"></a>G1收集器高效率</h4><p><img src="/image/JVM/G1%E6%94%B6%E9%9B%86%E5%99%A8%E9%AB%98%E6%95%88%E7%8E%87.png"></p><h4 id="G1在开发过程中的问题和解决方案"><a href="#G1在开发过程中的问题和解决方案" class="headerlink" title="G1在开发过程中的问题和解决方案"></a>G1在开发过程中的问题和解决方案</h4><ul><li>Region中存在跨Region引用对象如何解决</li></ul><p>  使用记忆集避免全堆作为GC Roots扫描，G1记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号，它是一种“双向”的卡表结构（卡表是：我指向谁，这种结构还记录了谁指向我）</p><ul><li><p>在并发标记阶段如何保证收集线程和用户线程互不干扰地进行</p><p><img src="/image/JVM/G1%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98.png"></p></li><li><p>如何建立起可靠的停顿预测模型</p><p>以衰减均值为理论基础来实现的</p></li></ul><h4 id="G1收集器的运作过程"><a href="#G1收集器的运作过程" class="headerlink" title="G1收集器的运作过程"></a>G1收集器的运作过程</h4><p>在不计算用户线程运行过程</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选标记</li></ul><p><img src="/image/JVM/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>可以由用户指定期望的停顿时间是G1收集器很强大的一个功能，设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。但是如果我们把停顿时间调的非常低，很有可能出现的结果就是由于停顿时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集器收集的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积</p><h4 id="为什么说G1是垃圾收集器技术发展的一个里程碑"><a href="#为什么说G1是垃圾收集器技术发展的一个里程碑" class="headerlink" title="为什么说G1是垃圾收集器技术发展的一个里程碑"></a>为什么说G1是垃圾收集器技术发展的一个里程碑</h4><p>从G1开始最先进的垃圾收集器设计导向都不约而同地变为追求能够应付应用的内存分配速率，而不追求一次把 整个Java堆全部清理干净。这样，应用在分配，同时收集器在收集，只要收集的速度能跟上对象分配的速度，那一切就可以运作得很完美</p><h4 id="G1收集器和CMS收集器的优缺点"><a href="#G1收集器和CMS收集器的优缺点" class="headerlink" title="G1收集器和CMS收集器的优缺点"></a>G1收集器和CMS收集器的优缺点</h4><p><img src="/image/JVM/G1%E5%92%8CCMS%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png"></p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>定义：Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称为虚拟机的类加载机制</p><h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p><img src="/image/JVM/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这个顺序按部就班的开始，而解析阶段则不一定：它在某些情况下可以在初始化后开始，这是为了支持Java语言的运行时绑定特性。请注意这里说的是各阶段按部就班的开始，而不是按部就班的进行，言下之意就是不是等一个阶段结束在进行下一个阶段，而是有可能两个阶段交叉相互执行</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载阶段，Java虚拟机需要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ol><p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，任然属于连接阶段的一部分，这两个阶段的开始时间任然保持着固定的先后顺序</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全</p><p>验证阶段大致上会完成下面四个阶段的验证动作：</p><ol><li><p>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</p><p>目的：保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求</p></li><li><p>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求</p><p>目的：对类的元数据信息进行语义校验</p></li><li><p>字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为</p></li><li><p>符号引用验证：此验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中各种符号引用）的各类信息进行匹配性校验，也就是该类是否缺少活着被禁止访问它依赖的某些外部类、方法、字段等资源</p><p>目的：确保解析阶段可以正常进行</p></li></ol><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段（在方法区中来分配内存，值得注意的是在JDK7之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK8及之后，类变量则会随着class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了）</p><p>在准备阶段进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配到Java堆中</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化阶段是类加载过程中的最后一个步骤。进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以说初始化阶段就是执行类构造器clinit()方法的过程</p><p>clinit()方法：</p><p>此方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(statin{}块)中的语句合并产生的，clinit()方法与类的构造函数（即在虚拟机视角中的实例构造器init()方法）不同，它不需要显示地调用父类构造器，Java虚拟机会保证在子类的clinit（）方法执行前，父类的clinit()方法已经执行完毕。所以在Java虚拟机中第一个被执行的linit()方法的类型肯定是java.lang.Object</p><p>由于父类的clinit()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</p><p>clinit()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成clinit()方法</p><p>Java虚拟机必须保证一个类的clinit()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的clinit()方法，其他线程都需要阻塞等待。直到活动线程执行完毕clinit()方法</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）</p><p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的加载器不同，那么这两个就必定不相等</p><p>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用了instanceof关键字做对象所属关系判定等各种情况</p><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul><li><strong>启动类加载器(Bootstrap ClassLoader)：</strong><br>负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath参数指定路径中的，并且被虚拟机认可(按文件名识别，如rt.jar)的类</li><li><strong>扩展类加载器(Extension ClassLoader)：</strong><br>负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库</li><li><strong>应用程序类加载器(Application ClassLoader)：</strong><br>负责加载用户路径（classpath）上的类库</li></ul><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父 类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载<br><strong>双亲委派模型的优点：</strong><br>保证了使用不同的类加载 器最终得到的都是同样一个Object 对象</p><h2 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h2><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>Java内存模型的主要目的：定义程序中各种变量（能够被共享的变量）的访问规则，关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节</p><p>Java内存模型规定所有的变量都存储在主内存（在物理上它仅是虚拟机内存的一部分）中。每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的操作都必须在工作内存中进行，而不能直接读写主内存中的数据</p><p><img src="/image/JVM/%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png"></p><p>我们可以近似于把主内存和工作内存看成Java堆和虚拟机栈，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应虚拟机栈的部分区域，但是他们基本上是没有任何关系的</p><h4 id="内存的交互操作"><a href="#内存的交互操作" class="headerlink" title="内存的交互操作"></a>内存的交互操作</h4><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝带工作内存，如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下八种操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的</p><ul><li>lock（锁定）</li><li>unlock（解锁）</li><li>read（读取）</li><li>load（载入）</li><li>use（使用）</li><li>assign（赋值）</li><li>store（存储）</li><li>write（写入）</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello Spring</title>
    <link href="/2023/07/19/Spring6/"/>
    <url>/2023/07/19/Spring6/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring6"><a href="#Spring6" class="headerlink" title="Spring6"></a>Spring6</h2><h3 id="OCP开闭原则"><a href="#OCP开闭原则" class="headerlink" title="OCP开闭原则"></a>OCP开闭原则</h3><p>对拓展开放，对修改关闭</p><h3 id="DIP依赖倒置原则"><a href="#DIP依赖倒置原则" class="headerlink" title="DIP依赖倒置原则"></a>DIP依赖倒置原则</h3><p>提倡面向抽象编程，面向接口编程，不要面向具体编程，让上层不再依赖下层</p><h3 id="IoC控制反转"><a href="#IoC控制反转" class="headerlink" title="IoC控制反转"></a>IoC控制反转</h3><p>控制反转（Inversion of Control)，是一种面向对象编程的设计思想，可以用来降低代码之间的耦合度，符合依赖倒置原则</p><p>核心思想：<strong>将对象创建的权利交出去，将对象和对象之间关系维护的管理权交出去，让第三方容器来负责创建和维护</strong></p><p>方式：依赖注入（DI）</p><h3 id="Spring8大模块"><a href="#Spring8大模块" class="headerlink" title="Spring8大模块"></a>Spring8大模块</h3><p>Spring5中加入了Spring WebFlux构成八大模块</p><ul><li>Spring Core模块：这是Spring框架最基础的部分，她提供了依赖注入特征来实现容器对Bean的管理。核心容器的主要组件是BeanFactory，BeanFactory是工厂模式的一个实现，是任何Spring的核心。它使用IoC将应用配置和依赖从实际的应用代码中分离出来</li><li>Spring Context模块：Spring上下文模块就是Spring成为框架的原因。这个模块拓展了BeanFactory。增加了对国际化消息、事件传播、验证的支持。</li><li>Spring AOP模块：面向切面编程</li><li>Spring DAO模块：提供了单独的支持JDBC操作的API</li><li>Spring ORM模块：Spring提供了ORM模块，也可以集成其他ORM，例如：MyBatis、Hibernate</li><li>Spring Web MVC模块：Spring为构建Web应用提供了一个功能全面的MVC框架。</li><li>Spring WebFlux模块</li><li>Spring Web模块</li></ul><h3 id="Spring特点"><a href="#Spring特点" class="headerlink" title="Spring特点"></a>Spring特点</h3><p>轻量、控制反转、面向切面、容器、框架</p><h3 id="set注入的实现原理"><a href="#set注入的实现原理" class="headerlink" title="set注入的实现原理"></a>set注入的实现原理</h3><p>通过反射机制调用该对象的set方法来给属性赋值，让两个对象之间产生关系</p><h3 id="简单类型包括"><a href="#简单类型包括" class="headerlink" title="简单类型包括"></a>简单类型包括</h3><ul><li>基本数据类型及其对应的包装类</li><li>String或其他的CharSequence子类</li><li>Number子类</li><li>Date子类</li><li>Enum子类</li><li>URL</li><li>URI</li><li>Temporal子类</li><li>Locale</li><li>Class</li></ul><p>如果我们把Date当做简单类型的话，日期字符串格式不能随便写。格式必须符合Date的toString（）方法的格式</p><h3 id="Bean对象的创建"><a href="#Bean对象的创建" class="headerlink" title="Bean对象的创建"></a>Bean对象的创建</h3><p>默认情况下Bean是单例的，此时Bean对象的创建是在初始化Spring上下文的时候完成的</p><p>当Bean是多例的时，Bean对象的创建是在调用getBean（）方法时创建，并且调用一次创建一次</p><h3 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h3><ul><li>singleton：默认的，单例</li><li>prototype：原型。每调用一次getBean（）方法则获取一个新的Bean对象。</li><li>request：一个请求对应一个Bean</li><li>session：一个对话一个Bean</li><li>global session：protlet应用中专用</li><li>application：一个应用一个Bean</li><li>websocket：一个websocket一个Bean</li><li>自定义scope</li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="工厂模式的三种形态："><a href="#工厂模式的三种形态：" class="headerlink" title="工厂模式的三种形态："></a>工厂模式的三种形态：</h4><ul><li>简单工厂模式：很多物品对应一个工厂，不属于23种设计模式</li><li>工厂方法模式：一个物品对应一个工厂</li><li>抽象工厂模式</li></ul><h3 id="Bean的实例化"><a href="#Bean的实例化" class="headerlink" title="Bean的实例化"></a>Bean的实例化</h3><p>Bean实例化的方式：</p><ul><li>通过构造方法实例化：调用对象的无参构造进行实例化</li><li>通过简单工厂实例化</li><li>通过factory-bean实例化</li><li>通过FactoryBean接口实例化</li></ul><p>factory-bean实例化和FactoryBean不一样。</p><p>1.写法不一样，前者是通过两个<bean/>实现,后者是通过实现FactoryBean接口实现。</p><p>2.实现时机不一样，前者是在创建spring容器时通过dom4j读取<bean/>标签中的内容创建。后者是在执行getBean()获取他时创建。</p><h3 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h3><p>BeanFactory：Spring IoC容器的顶级对象，BeanFactory被翻译为“Bean工厂”，在Spring的IoC中，“Bean工厂”负责创建Bean对象。BeanFactory是工厂</p><p>FactoryBean：它是一个Bean，是一个能够辅助Spring实例化其他Bean对象的一个Bean</p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p>以Bean生命周期之10步为例：</p><ul><li><p><strong>实例化Bean</strong>：调用无参数构造方法</p></li><li><p><strong>Bean属性赋值</strong>：调用set方法</p></li><li><p>检查Bean是否实现了Aware的相关接口，并设置相关依赖（BeanNameAware、BeanClassLoaderAware、BeanFactoryAware）如果要在实例化Bean时要执行某些代码就可以通过实现Aware接口来完成</p></li><li><p><strong>Bean后处理器before执行</strong></p></li><li><p>检查Bean是否实现了InitializingBean接口，并调用接口方法</p></li><li><p><strong>初始化Bean</strong>：调用init方法，这个init方法需要我们自己写</p></li><li><p><strong>Bean后处理器after执行</strong></p></li><li><p><strong>使用Bean</strong></p></li><li><p>检查Bean是否实现了DisposableBean接口，并调用接口方法</p></li><li><p><strong>销毁Bean</strong>：调用自己写的destory方法</p><p>如果你想在初始化前和初始化后添加代码，可以加入“Bean后处理器”。</p><p>编写一个类实现BeanPostProcessor类，并且重写before和after方法</p></li></ul><h3 id="自己new的对象如何让Spring管理"><a href="#自己new的对象如何让Spring管理" class="headerlink" title="自己new的对象如何让Spring管理"></a>自己new的对象如何让Spring管理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//自己new的对象</span><br>User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><span class="hljs-comment">//创建 默认可列表BeanFactory对象</span><br>DefaultListableBeanFactory factory=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span>();<br><span class="hljs-comment">//注册Bean</span><br>factory.registerSingleton(<span class="hljs-string">&quot;userBean&quot;</span>,user);<br><span class="hljs-comment">//从Spring中获取bean</span><br>User userBean=factory.getBean(<span class="hljs-string">&quot;userBean&quot;</span>,User.class);<br></code></pre></td></tr></table></figure><h3 id="Bean的循环依赖问题"><a href="#Bean的循环依赖问题" class="headerlink" title="Bean的循环依赖问题"></a>Bean的循环依赖问题</h3><h4 id="singleton-set注入下"><a href="#singleton-set注入下" class="headerlink" title="singleton+set注入下"></a>singleton+set注入下</h4><p>在此情况下循环依赖是没有问题的</p><h4 id="singleton-构造注入下"><a href="#singleton-构造注入下" class="headerlink" title="singleton+构造注入下"></a>singleton+构造注入下</h4><p>在此情况下是不能解决循环依赖问题，主要原因就是通过构造方法注入会导致实例化对象的过程和对象属性赋值的过程没有分离开，必须在一起完成导致的</p><h4 id="Spring解决循环依赖问题的机理"><a href="#Spring解决循环依赖问题的机理" class="headerlink" title="Spring解决循环依赖问题的机理"></a>Spring解决循环依赖问题的机理</h4><p>通过singleton+set注入这种方式，将实例化对象和给对象属性赋值分开完成</p><p>实例化Bean的时候：调用无参数构造方法来完成。<strong>此时可以先不给属性赋值，可以提前将该Bean对象“曝光”给外界</strong></p><p>给Bean属性赋值的时候：调用setter方法来完成</p><p>这两个步骤是完全分离开来完成</p><h3 id="Bean的缓存问题"><a href="#Bean的缓存问题" class="headerlink" title="Bean的缓存问题"></a>Bean的缓存问题</h3><p>Bean的三级缓存：</p><ul><li>一级缓存（单例对象的缓存）：key存储bean名称，value存储Bean对象</li><li>二级缓存（早期单例对象的缓存）：key存储bean名称，value存储早期的Bean</li><li>三级缓存（单例工厂缓存）：key存储bean名称，value存储该Bean的ObjectFactory对象</li></ul><p>在DefaultSingletonBeanRegistry类中有一个addSingletonFactory（）方法，这个方法的作用是：将创建Bean对象的ObjectFactory对象提前曝光</p><p><img src="/image/Spring6/image1.png"></p><p>从源码分析可知：</p><p><img src="/image/Spring6/image.png"></p><h3 id="声明Bean的注解"><a href="#声明Bean的注解" class="headerlink" title="声明Bean的注解"></a>声明Bean的注解</h3><ul><li>@Component</li><li>@Controller</li><li>@Service</li><li>@Repository</li></ul><p><img src="/image/Spring6/image2.png"></p><p>value是可以省略的，省略后默认名字是Bean类名首字母小写</p><h3 id="负责注入的注解"><a href="#负责注入的注解" class="headerlink" title="负责注入的注解"></a>负责注入的注解</h3><ul><li><p>@Value：简单类型进行注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.powernode.spring6.bean4;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@Value(value = &quot;zhangsan&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;20&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>@Autowired：默认通过类型自动装配</p></li><li><p>@Qualifier：中指定Bean名称</p><p>这两个注解要结合起来使用，@Autowired根据类型自动装配，@Qualifier根据名字进行自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.powernode.spring6.service;<br><br><span class="hljs-keyword">import</span> com.powernode.spring6.dao.UserDao;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;userDaoForOracle&quot;)</span> <span class="hljs-comment">// 这个是bean的名字。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>        userDao.insert();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Autowired注解可以出现在：属性上、构造方法上、构造方法的参数上、setter方法上</p><p>当带参数的构造方法只有一个，@Autowired可以省略</p><p>@Autowired注解默认根据类型注入。如果要根据名称注入的话，需要配合@Qualifier注解一起使用</p></li><li><p>@Resource</p><p>该注解是JDK扩展包中的，就是说是JDK的一部分，@Autowired是Spring框架自己的</p><p>@Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配</p><p>@Resource注解可以用到属性上、setter方法上</p></li></ul><h3 id="Spring的全注解式开发"><a href="#Spring的全注解式开发" class="headerlink" title="Spring的全注解式开发"></a>Spring的全注解式开发</h3><p>通过以下配置来代替xml文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&#123;&quot;com.powernode.spring6.da0&quot;,&quot;com.powernode.spring6.service&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Spring6Configuration</span>()&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>JDK动态代理：只能代理接口，<strong>通过反射机制来动态代理</strong></p><p>CGLIB动态代理：是一个强大的，高性能的，高质量的Code生成类库，它可以在运行期间扩展Java类与实现Java接口。它既可以代理接口也可以代理类，<strong>底层是通过继承的方式实现的</strong>。性能比JDK动态代理要好（底层是一个小而快的字节码处理框架ASM）</p><p>javassist动态代理：通过使用javassist对字节码操作作为JBoss实现动态“AOP”框架</p><h3 id="面向切面编程AOP"><a href="#面向切面编程AOP" class="headerlink" title="面向切面编程AOP"></a>面向切面编程AOP</h3><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>一般一个系统当中都会有一些系统服务，例如：日志、事务管理、安全等。这些系统服务被称为：<strong>交叉业务</strong></p><p>AOP：将于核心业务无关的代码独立的抽取出来，形成一个独立的组件，然后以横向交叉的方法应用到业务流程当中的过程被称为AOP</p><p><img src="/image/Spring6/image3.png"></p><h4 id="AOP的七大术语"><a href="#AOP的七大术语" class="headerlink" title="AOP的七大术语"></a>AOP的七大术语</h4><ul><li><p>连接点Joinpoint</p></li><li><p>切点Pointcut</p></li><li><p>通知Advice</p></li><li><p>切面Aspect</p><p>切面&#x3D;切点+通知</p></li><li><p>织入</p></li><li><p>代理对象</p></li><li><p>目标对象</p></li></ul><p><img src="/image/Spring6/image4.png"></p><h4 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">execution([访问控制权限修饰符] 返回值类型 [全限定类名] 方法名(形式参数列表) [异常])<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">访问控制权限修饰符：</span><br><span class="hljs-comment">   可选项。</span><br><span class="hljs-comment">   没写，就是4个权限都包括。</span><br><span class="hljs-comment">   写public就表示只包括公开的方法。</span><br><span class="hljs-comment">返回值类型：</span><br><span class="hljs-comment">   必填项。</span><br><span class="hljs-comment">   * 表示返回值类型任意。</span><br><span class="hljs-comment">全限定类名：</span><br><span class="hljs-comment">   可选项。</span><br><span class="hljs-comment">   两个点“..”代表当前包以及子包下的所有类。</span><br><span class="hljs-comment">   省略时表示所有的类。</span><br><span class="hljs-comment">方法名：</span><br><span class="hljs-comment">   必填项。</span><br><span class="hljs-comment">   *表示所有方法。</span><br><span class="hljs-comment">   set*表示所有的set方法。</span><br><span class="hljs-comment">形式参数列表：</span><br><span class="hljs-comment">   必填项</span><br><span class="hljs-comment">   () 表示没有参数的方法</span><br><span class="hljs-comment">   (..) 参数类型和个数随意的方法</span><br><span class="hljs-comment">   (*) 只有一个参数的方法</span><br><span class="hljs-comment">   (*, String) 第一个参数类型随意，第二个参数是String的。</span><br><span class="hljs-comment">异常：</span><br><span class="hljs-comment">   可选项。</span><br><span class="hljs-comment">   省略时表示任意异常类型</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//service包下所有的类中以delete开始的所有方法</span><br>   execution(<span class="hljs-keyword">public</span> * com.powernode.service.*.delete*(..)) <br></code></pre></td></tr></table></figure><h3 id="Spring中对事务的控制"><a href="#Spring中对事务的控制" class="headerlink" title="Spring中对事务的控制"></a>Spring中对事务的控制</h3><h4 id="声明式事务（Transaction）"><a href="#声明式事务（Transaction）" class="headerlink" title="声明式事务（Transaction）"></a>声明式事务（Transaction）</h4><p><code>@Transaction</code> 注解的底层原理涉及到 Spring 框架的两个核心机制：AOP（面向切面编程）和事务管理。</p><p>当一个方法被 <code>@Transaction</code> 注解标注后，Spring 会使用 AOP 机制，将事务管理的逻辑从业务逻辑中分离出来，并动态地生成一个代理对象。代理对象会包装原始对象，并在原始对象的方法执行前后添加一些事务管理的逻辑，比如开启事务、提交事务或回滚事务等。</p><p>具体来说，Spring 通过使用 JDK 动态代理或 CGLIB（Code Generation Library）字节码生成技术，在运行时动态地生成代理对象。当一个被 <code>@Transaction</code> 注解标注的方法被调用时，实际上是调用了代理对象的方法。代理对象会在方法执行前后织入事务管理的逻辑，实现事务的自动管理。</p><p>当方法执行成功时，代理对象会提交事务，将数据库中的数据持久化。如果方法执行失败，代理对象会回滚事务，保证数据的一致性和完整性。</p><p>总之，<code>@Transaction</code> 注解的底层原理是通过 AOP 机制和事务管理机制相结合实现的。通过动态生成代理对象，在原始对象的方法执行前后添加事务管理的逻辑，从而实现了自动的事务管理。</p><h4 id="Spring中事务失效的情况"><a href="#Spring中事务失效的情况" class="headerlink" title="Spring中事务失效的情况"></a>Spring中事务失效的情况</h4><ol><li>方法没有被 Spring 托管：Spring 只能管理由 Spring 容器管理的 bean，如果一个方法不是由 Spring 容器管理的，那么 Spring 将无法管理它的事务，事务也就会失效。（非代理对象不会被Spring托管，所以非代理对象的事务也不会生效）</li><li>事务传播属性设置不当：事务传播属性可以控制事务在多个方法调用时的行为。如果事务传播属性设置不当，比如使用了 <code>Propagation.REQUIRES_NEW</code> 传播属性，那么将会导致当前事务挂起，新的事务被启动，从而导致事务失效。</li><li>异常没有被正确处理：Spring 的事务管理机制默认情况下只会对受检查的异常（Checked Exception）进行回滚操作。如果业务逻辑中抛出了未受检查的异常（Unchecked Exception）或 Error，而且没有正确地处理这些异常，那么就可能导致事务失效。</li><li>事务的边界设置不当：事务的边界应该设置在包含所有涉及到数据库操作的方法的最外层，如果事务的边界设置不当，可能会导致某些数据库操作没有被包含在事务中，从而导致事务失效。</li><li>数据库表引擎不支持事务：一些数据库表引擎，比如 MyISAM，不支持事务。如果在使用这些数据库表引擎的情况下尝试进行事务管理，那么事务将无法生效。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/07/19/hello-world/"/>
    <url>/2023/07/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Hello-Zyw"><a href="#Hello-Zyw" class="headerlink" title="Hello Zyw"></a>Hello Zyw</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><h3 id="那就从这里开始吧"><a href="#那就从这里开始吧" class="headerlink" title="那就从这里开始吧"></a>那就从这里开始吧</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
